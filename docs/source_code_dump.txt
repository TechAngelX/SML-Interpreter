-e \n\n===== File: ./src/test/java/sml/instructions/GotoInstructionTest.java =====\n
package sml.instructions;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import sml.*;

import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;

/**
 * Test suite for the GotoInstruction in the Simple Machine Language.
 *
 * <p>Validates the functionality of unconditional jump instructions within the SML runtime.</p>
 *
 * <p>Key test objectives:</p>
 * <ul>
 *   <li>Verifying successful label jumping</li>
 *   <li>Handling error scenarios for missing labels</li>
 *   <li>Ensuring correct program counter manipulation</li>
 * </ul>
 *
 * @author Ricki Angel
 */

public class GotoInstructionTest {
    private Machine machine;

    @BeforeEach
    void setUp() {
        machine = new Machine();
    }

    @AfterEach
    void tearDown() {
        machine = null;
    }

    @Test
    @DisplayName("Should successfully execute a valid goto instruction")
    void validGotoInstruction() {
        Instruction ins0 = new GotoInstruction(null, new Label("L1"));
        Instruction ins1 = new ReturnInstruction(null);
        Instruction ins2 = new ReturnInstruction(new Label("L1"));

        Method m = new Method(new Method.Identifier("@main"), List.of(), List.of(ins0, ins1, ins2));
        machine.setProgram(List.of(m));
        Optional<Frame> frame = ins0.execute(machine);
        assertEquals(2, frame.get().programCounter());
    }

    @Test
    @DisplayName("Should throw LabelNotFoundException for missing labels")
    void missingLabelGotoInstruction() {
        Label missingLabel = new Label("L2");

        Instruction ins0 = new GotoInstruction(null, missingLabel);
        Instruction ins1 = new ReturnInstruction(null);

        Method m = new Method(new Method.Identifier("@main"), List.of(), List.of(ins0, ins1));

        machine.setProgram(List.of(m));

        // Execute the GotoInstruction (ins0), expecting it to throw a LabelNotFoundException
        // because the label "L2" is missing:
        LabelNotFoundException ex = assertThrows(LabelNotFoundException.class, () -> ins0.execute(machine));


        assertEquals("Label L2 not found in main", ex.getMessage());

        assertEquals(missingLabel, ex.getLabel(), "Exception should contain the missing label");
        assertEquals(m, ex.getMethod(), "Exception should reference the correct method");
    }
}
-e \n\n===== File: ./src/test/java/sml/instructions/IfCmpgtInstructionTest.java =====\n
package sml.instructions;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import sml.*;

import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Test class for the IfCmpgtInstruction in the Simple Machine Language.
 *
 * <p>Validates the functionality of conditional greater-than comparison instructions.</p>
 *
 * <p>Test scenarios cover various comparison conditions:</p>
 * <ul>
 *   <li>Jumping when first value is greater than the second</li>
 *   <li>Continuing sequentially when first value is not greater</li>
 *   <li>Handling equal value comparisons</li>
 * </ul>
 *
 * @author Ricki Angel
 */

public class IfCmpgtInstructionTest {
    private Machine machine;

    @BeforeEach
    void setUp() {
        machine = new Machine();
    }

    /**
     * Verifies that the {@link IfCmpgtInstruction} correctly advances to the next instruction
     * (at index 1) when the first value popped from the stack is larger than the second.
     * <p>
     * This test confirms that the instruction proceeds sequentially when the comparison condition
     * (first value greater than second) is met. Specifically, it validates the non-jump behavior
     * by ensuring that the program counter advances to the instruction immediately following
     * the comparison instruction, which is located at index 1 in the instruction list.
     * </p>
     */
    @Test
    @DisplayName("Should jump when first value is greater than second")
    void testShouldJumpWhenFirstValueGreater() {
        Label jumpLabel = new Label("jump");
        Label returnLabel = new Label("return");

        Instruction ifGreaterGotoInstruction = new IfCmpgtInstruction(null, jumpLabel);
        Instruction nextInstruction = new ReturnInstruction(returnLabel);
        Instruction jumpTargetInstruction = new ReturnInstruction(jumpLabel);

        Method mainMethod = new Method(
                new Method.Identifier("@main"),
                List.of(),
                List.of(ifGreaterGotoInstruction, nextInstruction, jumpTargetInstruction)
        );
        machine.setProgram(List.of(mainMethod));

        machine.frame().push(10);
        machine.frame().push(5);

        Optional<Frame> nextFrame = ifGreaterGotoInstruction.execute(machine);

        assertTrue(nextFrame.isPresent(), "Next frame should exist");
        int programCounter = nextFrame.get().programCounter();
        assertEquals(2, programCounter, "Should jump to the jumptarget instruction at index 2");
    }

    @Test
    @DisplayName("Should continue to next instruction when first value is not greater")
    void testContinueToNextInstructionWhenFirstValueNotGreater() {
        Label jumpLabel = new Label("jump");
        Label returnLabel = new Label("return");

        Instruction ifGreaterGotoInstruction = new IfCmpgtInstruction(null, jumpLabel);
        Instruction nextInstruction = new ReturnInstruction(returnLabel);
        Instruction jumpTargetInstruction = new ReturnInstruction(jumpLabel);

        Method mainMethod = new Method(
                new Method.Identifier("@main"),
                List.of(),
                List.of(ifGreaterGotoInstruction, nextInstruction, jumpTargetInstruction)
        );
        machine.setProgram(List.of(mainMethod));
        machine.frame().push(36);
        machine.frame().push(101);

        Optional<Frame> nextFrame = ifGreaterGotoInstruction.execute(machine);

        assertTrue(nextFrame.isPresent(), "Next frame should exist");
        int programCounter = nextFrame.get().programCounter();
        assertEquals(1, programCounter, "if first value smaller than second, should not jump, but continue to next instruction");
    }

    @Test
    @DisplayName("Should continue to next instruction when values are equal")
    void testContinueToNextInstructionIfFirstAndSecondValueAreEqual() {
        Label jumpLabel = new Label("jump");
        Label returnLabel = new Label("return");

        Instruction ifGreaterGotoInstruction = new IfCmpgtInstruction(null, jumpLabel);
        Instruction nextInstruction = new ReturnInstruction(returnLabel);
        Instruction jumpTargetInstruction = new ReturnInstruction(jumpLabel);

        Method mainMethod = new Method(
                new Method.Identifier("@main"),
                List.of(),
                List.of(ifGreaterGotoInstruction, nextInstruction, jumpTargetInstruction)
        );
        machine.setProgram(List.of(mainMethod));
        machine.frame().push(4);
        machine.frame().push(4);

        Optional<Frame> nextFrame = ifGreaterGotoInstruction.execute(machine);

        assertTrue(nextFrame.isPresent(), "Next frame should exist");
        int programCounter = nextFrame.get().programCounter();
        assertEquals(1, programCounter, "If equal, should not jump, but continue to the next instruction at index 1");
    }
}
-e \n\n===== File: ./src/test/java/sml/instructions/StoreInstructionTest.java =====\n
package sml.instructions;

import sml.*;

import org.junit.jupiter.api.*;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Test suite for the StoreInstruction in the Simple Machine Language.
 *
 * <p>Validates the behavior of variable storage instructions within the SML runtime.</p>
 *
 * <p>Key test objectives:</p>
 * <ul>
 *   <li>Storing values from the stack to variables</li>
 *   <li>Handling non-existent variable scenarios</li>
 *   <li>Verifying variable storage method implementation</li>
 * </ul>
 *
 * @author Ricki Angel
 */

public class StoreInstructionTest {
    private Machine machine;

    @BeforeEach
    void setUp() {
        machine = new Machine();
    }

    @AfterEach
    void tearDown() {
        machine = null;
    }

    @Test
    @DisplayName("Should successfully store a value from stack to a variable")
    void testStoreValueFromStackToVariable() {
        Variable.Identifier varId = new Variable.Identifier("testVar");

        Instruction storeInstruction = new StoreInstruction(null, varId);
        Instruction returnInstruction = new ReturnInstruction(null);

        Method mainMethod = new Method(
                new Method.Identifier("@main"),
                List.of(),
                List.of(storeInstruction, returnInstruction)
        );
        machine.setProgram(List.of(mainMethod));
        machine.frame().push(42);
        storeInstruction.execute(machine);

        Variable var = machine.frame().variable(varId);
        assertEquals(42, var.load());
    }

    @Test
    @DisplayName("Should throw VariableNotFoundException for non-existent variable")
    void testNonExistentVariableShouldThrowException() {
        Variable.Identifier nonExistentVarId = new Variable.Identifier("nonExistentVar");

        Method mainMethod = new Method(
                new Method.Identifier("@main"),
                List.of(),
                List.of(new ReturnInstruction(null))
        );
        machine.setProgram(List.of(mainMethod));
        assertThrows(VariableNotFoundException.class,
                () -> machine.frame().variable(nonExistentVarId));
    }

    @Test
    @DisplayName("Should return the correct variable when calling variables() method")
    void testStoreInstructionVariablesShouldReturnSingleVariable() {
        Variable.Identifier varId = new Variable.Identifier("testVar");
        StoreInstruction storeInstruction = new StoreInstruction(null, varId);

        List<Variable.Identifier> variables = storeInstruction.variables()
                .toList();

        assertEquals(1, variables.size());
        assertEquals(varId, variables.get(0));
    }

    @Test
    @DisplayName("Should correctly implement equals() method")
    void testEqualsMethod() {
        Variable.Identifier varId = new Variable.Identifier("testVar");
        Label label = new Label("testLabel");

        StoreInstruction instruction1 = new StoreInstruction(label, varId);
        StoreInstruction instruction2 = new StoreInstruction(label, varId);
        StoreInstruction instruction3 = new StoreInstruction(null, varId);

        assertEquals(instruction1, instruction2);
        assertNotEquals(instruction1, instruction3);

        assertNotEquals(instruction1, null);
        Assertions.assertNotEquals(instruction1, new LoadInstruction(label, varId));
    }

    @Test
    @DisplayName("Should generate consistent hash codes for equal objects")
    void testHashCodeMethod() {
        Variable.Identifier varId = new Variable.Identifier("testVar");
        Label label = new Label("testLabel");

        StoreInstruction instruction1 = new StoreInstruction(label, varId);
        StoreInstruction instruction2 = new StoreInstruction(label, varId);

        assertEquals(instruction1.hashCode(), instruction2.hashCode());
    }
}
-e \n\n===== File: ./src/test/java/sml/instructions/InstructionRegistrationManagerTest.java =====\n
package sml.instructions;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.junit.jupiter.params.provider.ValueSource;
import sml.*;

import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Test suite for the InstructionRegistrationManager.
 *
 * <p>Validates the dynamic instruction discovery and registration capabilities 
 * of the Simple Machine Language instruction system.</p>
 *
 * <p>Key test objectives:</p>
 * <ul>
 *   <li>Verifying instruction creation for standard and coursework supplementary instructions</li>
 *   <li>Handling instructions with different parameter requirements</li>
 *   <li>Testing instruction creation with various label configurations</li>
 *   <li>Ensuring robust handling of unknown or invalid opcodes</li>
 * </ul>
 *
 * @author Ricki Angel
 */
public class InstructionRegistrationManagerTest {
    private Label label;

    @BeforeEach
    void setUp() {
        label = new Label("L1");
    }
    /**
     * Provides a stream of arguments for testing simple instructions that only require a Label.
     *
     * @return a stream of opcodes for parameterized testing
     */
    static Stream<Arguments> provideSimpleInstructionsData() {
        return Stream.of(
                // Instructions that only need a Label parameter:
                Arguments.of("add", AddInstruction.class),
                Arguments.of("sub", SubInstruction.class),
                Arguments.of("mul", MulInstruction.class),
                Arguments.of("div", DivInstruction.class),
                Arguments.of("print", PrintInstruction.class),
                Arguments.of("return", ReturnInstruction.class),
                Arguments.of("sqrt", SqrtInstruction.class),
                Arguments.of("not_eq", NotEqInstruction.class),
                Arguments.of("mod", ModInstruction.class)
        );
    }

    @ParameterizedTest
    @DisplayName("Simple instructions with just Label parameter should be created successfully")
    @MethodSource("provideSimpleInstructionsData")
    void testSimpleInstructionsCreation(String opcode, Class<? extends Instruction> expectedClass) {
        Instruction instruction = InstructionRegistrationManager.createInstruction(opcode, label);

        assertNotNull(instruction, "Failed to create instruction for opcode: " + opcode);
        assertEquals(opcode, instruction.opcode(), "Created instruction has incorrect opcode");
        assertTrue(expectedClass.isInstance(instruction),
                "Instruction for opcode '" + opcode + "' should be instance of " + expectedClass.getSimpleName());
    }

    /**
     * Acknowledges complex instructions that require additional parameters beyond a simple label.
     *
     * <p>This method serves as a documentation point for instructions with more complex 
     * instantiation requirements. It highlights instructions that need differing params such as:</p>
     * <ul>
     *   <li>Variable identifiers</li>
     *   <li>Target labels</li>
     *   <li>Method identifiers</li>
     * </ul>
     *
     * <p>Key points:</p>
     * <ul>
     *   <li>Not intended for direct instruction creation testing</li>
     *   <li>Documents the existence of complex instructions in the factory</li>
     *   <li>Indirect validation through dedicated integration and unit tests</li>
     * </ul>
     *
     * @param opcode The operation code for complex instructions requiring special handling
     */

    @ParameterizedTest
    @DisplayName("Instructions that need additional parameters should not be testable with just a label")
    @ValueSource(strings = {"load", "store", "push", "goto", "if_cmpeq", "if_cmpgt", "invoke"})
    void testComplexInstructions(String opcode) {
    
    }

    @Test
    @DisplayName("Returns null when attempting to create instruction with invalid opcode")
    void testCreateInstructionWithUnknownOpcode() {
        Instruction instruction = InstructionRegistrationManager.createInstruction("unknownOpcode", label);
        assertNull(instruction, "Instruction should be null for unknown opcode");
    }

    @Test
    @DisplayName("Created instructions should preserve their labels")
    void testInstructionLabelsArePreserved() {
        Label customLabel = new Label("CUSTOM_LABEL");
        Instruction instruction = InstructionRegistrationManager.createInstruction("add", customLabel);

        assertTrue(instruction.optionalLabel().isPresent(), "Label should be present");
        assertEquals(customLabel, instruction.optionalLabel().get(), "Label should match the provided label");
    }

    @Test
    @DisplayName("Can create instruction with null label")
    void testCreateInstructionWithNullLabel() {
        Instruction instruction = InstructionRegistrationManager.createInstruction("add", null);

        assertNotNull(instruction, "Should create instruction even with null label");
        assertFalse(instruction.optionalLabel().isPresent(), "Label should not be present");
    }

    @Test
    @DisplayName("Supplementary instructions should be created correctly")
    void testSupplementaryInstructions() {
        Instruction modInstruction = InstructionRegistrationManager.createInstruction("mod", label);
        assertNotNull(modInstruction, "ModInstruction was not registered properly");
        assertTrue(modInstruction instanceof ModInstruction, "Should create a ModInstruction for mod opcode");

        Instruction notEqInstruction = InstructionRegistrationManager.createInstruction("not_eq", label);
        assertNotNull(notEqInstruction, "NotEqInstruction was not registered properly");
        assertTrue(notEqInstruction instanceof NotEqInstruction, "Should create a NotEqInstruction for not_eq opcode");

        Instruction sqrtInstruction = InstructionRegistrationManager.createInstruction("sqrt", label);
        assertNotNull(sqrtInstruction, "SqrtInstruction was not registered properly");
        assertTrue(sqrtInstruction instanceof SqrtInstruction, "Should create a SqrtInstruction for sqrt opcode");
        
        // ... I can add more supplementary test instructions here if ness.
    }
}
-e \n\n===== File: ./src/test/java/sml/instructions/NumCharInstructionTest.java =====\n
package sml.instructions;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import sml.Label;
import sml.Machine;
import sml.Method;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * Test suite for the NumCharInstruction in the Simple Machine Language.
 *
 * <p>Validates the functionality of converting numbers to characters within the SML runtime.</p>
 *
 * <p>Key test objectives:</p>
 * <ul>
 *   <li>Verifying correct character output for given numbers</li>
 *   <li>Handling edge case scenarios like zero input</li>
 *   <li>Ensuring proper stack manipulation and program flow</li>
 * </ul>
 *
 * @author Ricki Angel 
 */
class NumCharInstructionTest {
    private final ByteArrayOutputStream outContent = new ByteArrayOutputStream();
    private final PrintStream originalOut = System.out;

    private Machine machine;

    @BeforeEach
    void setUp() {
        machine = new Machine();
        System.setOut(new PrintStream(outContent));
    }

    @AfterEach
    void tearDown() {
        machine = null;
        System.setOut(originalOut);
    }

    /**
     * Verifies that the {@link NumCharInstruction} correctly converts a number 
     * to its corresponding alphabetic character and prints the result.
     *
     * <p>
     * This test pushes the number 3 onto the stack, executes the instruction, 
     * and asserts that the printed output matches the expected character "C".
     * </p>
     * 
     * @author Ricki Angel
     */

    @Test
    @DisplayName("Should print correct letter for given number")
    void testPrintsCorrectLetterForNumber() {
        NumCharInstruction instruction = new NumCharInstruction(null);
        Instruction returnInstruction = new ReturnInstruction(null);

        Method method = new Method(
                new Method.Identifier("@main"),
                List.of(),
                List.of(instruction, returnInstruction)
        );
        machine.setProgram(List.of(method));
        machine.frame().push(3);

        instruction.execute(machine);

        System.out.flush();

        assertEquals("C\n", outContent.toString());
    }

    @Test
    @DisplayName("Should handle zero as input number")
    void testHandlesZeroNumber() {
        Instruction instruction = new NumCharInstruction(new Label("L1"));
        Instruction returnInstruction = new ReturnInstruction(null);

        Method method = new Method(
                new Method.Identifier("@main"),
                List.of(),
                List.of(instruction, returnInstruction)
        );
        machine.setProgram(List.of(method));

        machine.frame().push(0);

        instruction.execute(machine);

        System.out.flush();

        assertEquals("@\n", outContent.toString());
    }
}
-e \n\n===== File: ./src/test/java/sml/instructions/SubInstructionTest.java =====\n
package sml.instructions;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import sml.*;

import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Test suite for verifying the SubInstruction's behavior in the Simple Machine Language.
 *
 * <p>Comprehensive testing of subtraction instruction functionality:</p>
 * <ul>
 *   <li>Accurate subtraction of stack-based operands</li>
 *   <li>Handling of positive and negative integer subtraction</li>
 *   <li>Correct stack manipulation during subtraction</li>
 *   <li>Ensuring proper program counter progression</li>
 * </ul>
 *
 * <p>Validates the subtraction instruction's correctness across various
 * computational scenarios and edge cases.</p>
 *
 * @author Ricki Angel
 */

public class SubInstructionTest {
    private Machine machine;

    @BeforeEach
    void setUp() {
        machine = new Machine();
        Method mainMethod = new Method(
                new Method.Identifier("@main"),
                List.of(),
                List.of(new ReturnInstruction(null))
        );
        machine.setProgram(List.of(mainMethod));
    }

    @Test
    @DisplayName("Should correctly subtract two numbers from the stack")
    void testExecuteSubInstruction() {
        Instruction subInstruction = new SubInstruction(null);
        Instruction returnInstruction = new ReturnInstruction(null);

        Method mainMethod = new Method(
                new Method.Identifier("@main"),
                List.of(),
                List.of(subInstruction, returnInstruction)
        );
        machine.setProgram(List.of(mainMethod));

        machine.frame().push(34);
        machine.frame().push(16);

        Optional<Frame> nextFrame = subInstruction.execute(machine);

        int result = machine.frame().pop();
        assertEquals(18, result, "34 - 16 should equal 18");

        assertTrue(nextFrame.isPresent(), "Next frame should exist");
        assertEquals(1, nextFrame.get().programCounter(), "Program counter should advance to next instruction");
    }

    @Test
    @DisplayName("Should handle subtraction with larger second operand")
    void testSubInstructionWithLargerSecondOperand() {
        Instruction subInstruction = new SubInstruction(null);
        Instruction returnInstruction = new ReturnInstruction(null);

        Method mainMethod = new Method(
                new Method.Identifier("@main"),
                List.of(),
                List.of(subInstruction, returnInstruction)
        );
        machine.setProgram(List.of(mainMethod));

        machine.frame().push(16);
        machine.frame().push(34);

        Instruction instruction = new SubInstruction(null);
        Optional<Frame> nextFrame = instruction.execute(machine);

        int result = machine.frame().pop();
        assertEquals(-18, result, "16 - 34 should equal -18");

        assertTrue(nextFrame.isPresent(), "Next frame should exist");
        assertEquals(1, nextFrame.get().programCounter(), "Program counter should advance to next instruction");
    }

    @Test
    @DisplayName("Should handle subtraction with zero")
    void testSubInstructionWithZero() {
        Instruction subInstruction = new SubInstruction(null);
        Instruction returnInstruction = new ReturnInstruction(null);

        Method mainMethod = new Method(
                new Method.Identifier("@main"),
                List.of(),
                List.of(subInstruction, returnInstruction)
        );
        machine.setProgram(List.of(mainMethod));

        machine.frame().push(100);
        machine.frame().push(60);

        Instruction instruction = new SubInstruction(null);
        Optional<Frame> nextFrame = instruction.execute(machine);

        int result = machine.frame().pop();
        assertEquals(40, result, "100 - 60 should equal 40");

        assertTrue(nextFrame.isPresent(), "Next frame should exist");
        assertEquals(1, nextFrame.get().programCounter(), "Program counter should advance to next instruction");
    }
}
-e \n\n===== File: ./src/test/java/sml/instructions/ConfigDiscoveryTest.java =====\n
package sml.instructions;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import sml.discovery.ConfigDiscovery;
import sml.helperfiles.DefaultInstructionRegistrationLogger;
import sml.helperfiles.InstructionRegistrationLogger;
import sml.registry.InstructionRegistry;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

import static org.junit.jupiter.api.Assertions.*;
/**
 * Test suite for validating the ConfigDiscovery instruction registration mechanism.
 *
 * <p>Comprehensive testing of configuration-based instruction discovery:</p>
 * <ul>
 *   <li>Verifying successful instruction registration from configuration</li>
 *   <li>Handling various configuration file scenarios</li>
 *   <li>Testing robustness against missing or empty configuration files</li>
 *   <li>Ensuring proper instruction class validation</li>
 * </ul>
 *
 * <p>Validates the dynamic instruction discovery process, ensuring
 * reliable and flexible instruction registration mechanisms.</p>
 *
 * @author Ricki Angel
 */
public class ConfigDiscoveryTest {
    private InstructionRegistry registry;
    private InstructionRegistrationLogger logger;

    @BeforeEach
    void setUp() {
        logger = new DefaultInstructionRegistrationLogger();
        registry = new InstructionRegistry();
    }

    /**
     * Verifies that the ConfigDiscovery can successfully discover and register instructions
     * from a test properties file created in memory. The test creates a mock configuration
     * with three instructions (add, sub, mul) and checks that they are correctly registered
     * in the instruction registry.
     */

    @Test
    @DisplayName("Should discover instructions from a configuration file")
    void testDiscoverInstructions() {
        Properties testProperties = new Properties();
        testProperties.setProperty("print", "sml.instructions.PrintInstruction");
        testProperties.setProperty("add", "sml.instructions.AddInstruction");
        testProperties.setProperty("sub", "sml.instructions.SubInstruction");

        ConfigDiscovery configDiscovery = new ConfigDiscovery(logger) {
            @Override
            protected InputStream getConfigResource(String configFile) {
                try {
                    ByteArrayOutputStream out = new ByteArrayOutputStream();
                    testProperties.store(out, "Test Properties");
                    return new ByteArrayInputStream(out.toByteArray());
                } catch (IOException e) {
                    return null;
                }
            }
        };

        int discoveredCount = configDiscovery.discoverInstructions(registry);
        assertTrue(registry.isRegistered("print"), "Print instruction should be registered");
        assertTrue(registry.isRegistered("add"), "add instruction should be registered");
        assertTrue(registry.isRegistered("sub"), "sub instruction should be registered");
    }

    /**
     * Tests the behavior of ConfigDiscovery when no configuration file is available.
     * Simulates a missing configuration file scenario and ensures that the discovery
     * method gracefully handles this situation by returning zero discovered instructions.
     */

    @Test
    @DisplayName("Should handle missing configuration file gracefully")
    void testMissingConfigurationFile() {
        ConfigDiscovery configDiscovery = new ConfigDiscovery(logger) {
            @Override
            protected InputStream getConfigResource(String configFile) {
                return null;
            }
        };
        int discoveredCount = configDiscovery.discoverInstructions(registry);
        assertEquals(0, discoveredCount, "Should return a 0 when config file is missing");
    }
    /**
     * Examines the ConfigDiscovery's response to an empty configuration file.
     * Ensures that when a configuration file exists but contains no instruction mappings,
     * the discovery method returns zero and does not attempt to register any instructions.
     */

    @Test
    @DisplayName("Should handle empty configuration file")
    void testEmptyConfigurationFile() {
        ConfigDiscovery configDiscovery = new ConfigDiscovery(logger) {
            @Override
            protected InputStream getConfigResource(String configFile) {
                Properties emptyProps = new Properties();
                try {
                    ByteArrayOutputStream out = new ByteArrayOutputStream();
                    emptyProps.store(out, "Empty Properties");
                    return new ByteArrayInputStream(out.toByteArray());
                } catch (IOException e) {
                    return null;
                }
            }
        };
        int discoveredCount = configDiscovery.discoverInstructions(registry);
        assertEquals(0, discoveredCount, "Should return 0 when config file is empty");
    }
}
-e \n\n===== File: ./src/test/java/sml/instructions/LoadInstructionTest.java =====\n
package sml.instructions;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import sml.*;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.util.List;
import java.util.stream.Collectors;

import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * Test suite for validating the LoadInstruction's functionality in the Simple Machine Language.
 *
 * <p>Focuses on verifying critical behaviors of variable loading operations:</p>
 * <ul>
 *   <li>Correctly loading values from variables</li>
 *   <li>Pushing loaded values onto the operand stack</li>
 *   <li>Ensuring proper interaction with the machine's execution frame</li>
 * </ul>
 *
 * <p>Test scenarios cover essential load instruction behaviors to guarantee
 * reliable variable value retrieval and stack manipulation.</p>
 *
 * @author Ricki Angel
 */
public class LoadInstructionTest {
    private final ByteArrayOutputStream outContent = new ByteArrayOutputStream();
    private Machine machine;

    @BeforeEach
    void setUp() {
        machine = new Machine();
    }

    @AfterEach
    void tearDown() {
        machine = null;
        System.setOut(System.out);
    }

    @Test
    @DisplayName("Should load and print a value from a variable")
    void loadInstructionShouldLoadAndPrintValue() {
        Variable.Identifier varId = new Variable.Identifier("testLoadVar");
        Instruction loadInstruction = new LoadInstruction(null, varId);
        Instruction returnInstruction = new ReturnInstruction(null);

        Method mainMethod = new Method(new Method.Identifier("@main"),
                List.of(), List.of(loadInstruction, returnInstruction));
        machine.setProgram(List.of(mainMethod));

        Variable variable = machine.frame().variable(varId);
        variable.store(55);

        System.setOut(new PrintStream(outContent));
        loadInstruction.execute(machine);

        assertEquals("55\n", outContent.toString());
    }

    @Test
    @DisplayName("Should return the correct variable when calling variables() method")
    void loadInstructionVariablesShouldReturnSingleVariable() {
        Variable.Identifier varId = new Variable.Identifier("testVar");
        LoadInstruction loadInstruction = new LoadInstruction(null, varId);
        List<Variable.Identifier> variables = loadInstruction.variables().collect(Collectors.toList());
        assertEquals(1, variables.size());
        assertEquals(varId, variables.get(0));
    }
}
-e \n\n===== File: ./src/test/java/sml/instructions/PushInstructionTest.java =====\n
package sml.instructions;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import sml.*;

import java.io.ByteArrayOutputStream;
import java.util.List;
import java.util.stream.Collectors;

import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * Test suite for validating the PushInstruction's behavior in the Simple Machine Language.
 *
 * <p>Comprehensive testing of constant value loading operations:</p>
 * <ul>
 *   <li>Correctly pushing literal values onto the operand stack</li>
 *   <li>Handling various integer constant inputs</li>
 *   <li>Verifying stack manipulation accuracy</li>
 * </ul>
 *
 * <p>Validates the push instruction's critical role in initializing
 * computational values and preparing stack-based operations.</p>
 *
 * @author Ricki Angel
 */
public class PushInstructionTest {
    private Machine machine;

    @BeforeEach
    void setUp() {
        machine = new Machine();
    }

    @AfterEach
    void tearDown() {
        machine = null;
        System.setOut(System.out);
    }

    @Test
    @DisplayName("Should push a value onto the stack")
    void testPushInstructionShouldPushValueOntoStack() {
        Instruction pushInstruction = new PushInstruction(null, 42);
        Instruction returnInstruction = new ReturnInstruction(null);

        Method mainMethod = new Method(new Method.Identifier("@main"),
                List.of(), List.of(pushInstruction, returnInstruction));
        machine.setProgram(List.of(mainMethod));

        pushInstruction.execute(machine);
        int poppedValue = machine.frame().pop();
        assertEquals(42, poppedValue);
    }

    @Test
    @DisplayName("Should return an empty stream for variables() method")
    void testPushInstructionVariablesShouldReturnEmptyStream() {
        Instruction pushInstruction = new PushInstruction(null, 42);
        List<Variable.Identifier> variables = pushInstruction.variables().collect(Collectors.toList());
        assertEquals(0, variables.size());
    }
}
-e \n\n===== File: ./src/test/java/sml/instructions/SmlIntegrationTest.java =====\n
package sml;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collection;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Comprehensive integration test suite for the Simple Machine Language runtime.
 *
 * <p>End-to-end validation of SML system functionality:</p>
 * <ul>
 *    <li>Creates actual SML temporary programs dynamically for testing various scenarios</li>
 *   <li>Verifying complete instruction set interactions</li>
 *   <li>Testing complex computational workflows</li>
 *   <li>Validating program translation and execution</li>
 *   <li>Ensuring robust runtime behavior across scenarios</li>
 * </ul>
 *
 * <p>Provides holistic testing of the SML interpreter's capabilities,
 * covering arithmetic, control flow, and method invocation scenarios.</p>
 *
 * @author Ricki Angel
 */

public class SmlIntegrationTest {
    private final ByteArrayOutputStream outContent = new ByteArrayOutputStream();
    private final PrintStream originalOut = System.out;
    private Translator translator;
    private Machine machine;

    @TempDir
    Path tempDir;

    @BeforeEach
    void setUp() {
        System.setOut(new PrintStream(outContent));
        translator = new Translator();
        machine = new Machine();
    }

    @AfterEach
    void tearDown() {
        System.setOut(originalOut);
    }

    /**
     * Creates a real life temporary SML file with the given content.
     * <p>
     * This method writes the provided SML program content to a file in a JUnit-managed
     * temporary directory. These files are created in your system's standard temporary
     * directory (typically /tmp on Unix or C:\Users\\username\AppData\Local\Temp on Windows)
     * and are automatically deleted when the test completes.
     * </p>
     *
     * @param filename The name to give the temporary file
     * @param content  The SML program content to write to the file
     * @return The absolute path to the created file
     * @throws IOException If an error occurs while creating or writing to the file
     * @author Ricki Angel
     */
    private String createTempSmlFile(String filename, String content) throws IOException {
        Path filePath = tempDir.resolve(filename);
        Files.writeString(filePath, content);
        return filePath.toString();
    }

    @Test
    @DisplayName("Test arithmetic operations (addition, subtraction, multiplication, division) and correct output")
    void testArithmeticOperations() throws IOException {
        String program = """
                @main:
                push 200
                push 50
                add     // 200 + 50 = 250
                print
                
                push 37
                push 6
                sub     // 37 - 6 = 31
                print
                
                push 6
                push 8
                mul     // 6 * 8 = 48
                print
                
                push 100
                push 4
                div     // 100 / 4 = 25
                print
                
                push 0  // Dummy value for return instruction to pop
                return
                """;

        String filePath = createTempSmlFile("arithmetic.sml", program);

        Collection<Method> methods = translator.readAndTranslate(filePath);
        machine.setProgram(methods);
        machine.execute();

        String output = outContent.toString();
        assertTrue(output.contains("250"), "Output of the addition result should be 250 (200+50)");
        assertTrue(output.contains("31"), "Output of the subtraction result should be 31 (37-6)");
        assertTrue(output.contains("48"), "Output of the multiplication result should be 48 (6*8)");
        assertTrue(output.contains("25"), "Output of the division result should be 25 (100/4)");
    }

    @Test
    @DisplayName("Verifies variable store and load operations with arithmetic computation")
    void testVariableOperations() throws IOException {
        String program = """
                @main:
                push 42
                store testVar
                push 8
                store otherVar
                load testVar
                load otherVar
                add
                print
                push 0  // Dummy push to prevent empty stack on return
                return
                """;

        String filePath = createTempSmlFile("variables.sml", program);

        Collection<Method> methods = translator.readAndTranslate(filePath);
        machine.setProgram(methods);
        machine.execute();

        String output = outContent.toString();
        assertTrue(output.contains("42"));
        assertTrue(output.contains("8"));
        assertTrue(output.contains("50"));
    }

    @Test
    @DisplayName("Test various jump instructions in SML, verifying correct conditional and unconditional jumps")
    void testJumpInstructions() throws IOException {
        String program = """
                @main:
                push 10
                push 20
                if_cmpeq notTakenJump     // 10 != 20, so this jump shoul NOT happen
                push 30
                goto unconditionalJump    // This jump SHOULD taken
                
                notTakenJump: push 999
                print
                
                unconditionalJump: push 40
                push 40
                if_cmpeq equalJump
                push 999
                
                equalJump: push 50
                push 25
                if_cmpgt greaterJump      // 50 > 25, so this jump should be taken
                push 999                  // This should never be executed
                
                greaterJump: push 60
                print                     // Should print 60
                return
                """;

        String filePath = createTempSmlFile("jumps.sml", program);
        Collection<Method> methods = translator.readAndTranslate(filePath);
        machine.setProgram(methods);
        machine.execute();

        // If all jumps work correctly, only 60 should be printed:
        String output = outContent.toString();
        assertFalse(output.contains("999"));
        assertTrue(output.contains("60"));
    }

    @Test
    @DisplayName("Should correctly calculate the 8th Fibonacci number")
    void testFibonacciProgram() throws IOException {
        // A Fibonacci program in SML, similar to the test1.sml:
        String program = """
                @main:
                push 8
                invoke @fib
                print
                push 0      // Push a dummy value for the return instruction
                return
                
                @fib: n
                load n
                push 2
                if_cmpgt recursive  // if n > 2, go to recursive case
                push 1            // base case: fib(1) = fib(2) = 1
                return
                
                recursive: load n
                push 1
                sub
                invoke @fib
                load n
                push 2
                sub
                invoke @fib
                add              // so it's now should be fib(n-1) + fib(n-2)
                return
                """;

        String filePath = createTempSmlFile("fibonacci.sml", program);

        Collection<Method> methods = translator.readAndTranslate(filePath);
        machine.setProgram(methods);
        machine.execute();

        String output = outContent.toString();

        String lastLine = output.lines()
                .filter(line -> line.matches("\\d+"))
                .reduce((first, second) -> second)
                .orElse("");
        assertEquals("21", lastLine, "The 8th Fibonacci number should be 21, but got: " + lastLine);
    }

    @Test
    @DisplayName("Should correctly calculate factorial(5) using recursion")
    void testRecursiveFactorialCalculation() throws IOException {
        String program = """
                @main:
                push 5
                invoke @factorial
                print
                push 0      // Add a dummy value for return to pop
                return
                
                @factorial: n
                load n
                push 1
                if_cmpeq baseCase
                load n
                load n
                push 1
                sub
                invoke @factorial
                mul
                return
                baseCase: push 1
                return
                """;

        String filePath = createTempSmlFile("factorial.sml", program);

        Collection<Method> methods = translator.readAndTranslate(filePath);
        machine.setProgram(methods);
        machine.execute();

        assertTrue(outContent.toString().contains("120"), "Expected output to contain factorial(5)=120, but didn't find it");
    }

    /**
     * Validates nested method call functionality in SML interpreter.
     *
     * <p>Verifies method invocation, stack-based argument passing,
     * and arithmetic operations within nested method calls. Specifically tests
     * that the @main method can successfully call the @inner method and process
     * its returned result.</p>
     *
     * @throws IOException if file creation fails
     * @author Ricki Angel
     */
    @Test
    @DisplayName("Verifies nested method calls with argument passing")
    void testNestedMethodInvocation() throws IOException {
        String program = """
                @main:
                push 10
                push 5
                invoke @inner // Call inner method with the previous two arguments from stack
                print         // Should print result (15)
                push 0        // Dummy push to prevent empty stack on return
                return
                
                @inner: a, b  // Declare parameters that will receive values from stack
                load a        // (10)
                load b        // (5)
                add
                return
                """;
        String filePath = createTempSmlFile("nested.sml", program);

        Collection<Method> methods = translator.readAndTranslate(filePath);

        machine.setProgram(methods);

        try {
            machine.execute();
        } catch (Exception e) {
            e.printStackTrace();
            fail("Unexpected exception during method execution: " + e.getMessage());
        }

        String output = outContent.toString();
        String lastLine = output.lines()
                .filter(line -> line.matches("\\d+"))
                .reduce((first, second) -> second)
                .orElse("");
        assertEquals("15", lastLine, "The result of 10 + 5 should be 15");
    }
}
-e \n\n===== File: ./src/test/java/sml/instructions/DivInstructionTest.java =====\n
package sml.instructions;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import sml.*;

import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Test suite for the DivInstruction in the Simple Machine Language.
 *
 * <p>Validates the functionality of division instructions within the SML runtime.</p>
 *
 * <p>Test scenarios cover:</p>
 * <ul>
 *   <li>Correct integer division of values from the operand stack</li>
 *   <li>Handling division with negative numbers</li>
 *   <li>Detecting and handling division by zero</li>
 *   <li>Verifying program counter progression</li>
 * </ul>
 *
 * @author Ricki Angel
 */
public class DivInstructionTest {
    private Machine machine;

    @BeforeEach
    void setUp() {
        machine = new Machine();
        Method mainMethod = new Method(
                new Method.Identifier("@main"),
                List.of(),
                List.of(new ReturnInstruction(null))
        );
        machine.setProgram(List.of(mainMethod));
    }

    @Test
    @DisplayName("Should correctly divide two numbers from the stack")
    void testExecuteDivInstruction() {
        Instruction divInstruction = new DivInstruction(null);
        Instruction returnInstruction = new ReturnInstruction(null);

        Method mainMethod = new Method(
                new Method.Identifier("@main"),
                List.of(),
                List.of(divInstruction, returnInstruction)
        );
        machine.setProgram(List.of(mainMethod));

        machine.frame().push(56);
        machine.frame().push(8);

        Optional<Frame> nextFrame = divInstruction.execute(machine);

        int result = machine.frame().pop();
        assertEquals(7, result, "56 / 8 should equal 7");

        assertTrue(nextFrame.isPresent(), "Next frame should exist");
        assertEquals(1, nextFrame.get().programCounter(), "Program counter should advance to next instruction");
    }

    @Test
    @DisplayName("Should handle division with negative numbers")
    void testDivisionWithNegativeNumbers() {
        Instruction divInstruction = new DivInstruction(null);
        Instruction returnInstruction = new ReturnInstruction(null);

        Method mainMethod = new Method(
                new Method.Identifier("@main"),
                List.of(),
                List.of(divInstruction, returnInstruction)
        );
        machine.setProgram(List.of(mainMethod));

        machine.frame().push(-56);
        machine.frame().push(8);

        Optional<Frame> nextFrame = divInstruction.execute(machine);

        int result = machine.frame().pop();
        assertEquals(-7, result, "-56 / 8 should equal -7");

        assertTrue(nextFrame.isPresent(), "Next frame should exist");
        assertEquals(1, nextFrame.get().programCounter(), "Program counter should advance to next instruction");
    }

    @Test
    @DisplayName("Should throw ArithmeticException when dividing by zero")
    void testDivisionByZero() {
        Instruction divInstruction = new DivInstruction(null);

        Method mainMethod = new Method(
                new Method.Identifier("@main"),
                List.of(),
                List.of(divInstruction)
        );
        machine.setProgram(List.of(mainMethod));

        machine.frame().push(50);
        machine.frame().push(0);

        assertThrows(ArithmeticException.class,
                () -> divInstruction.execute(machine),
                "Division by zero should throw ArithmeticException"
        );
    }
}
-e \n\n===== File: ./src/test/java/sml/instructions/IfCmpeqInstructionTest.java =====\n
package sml.instructions;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import sml.*;

import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
/**
 * Test class for the IfCmpgtInstruction in the Simple Machine Language.
 *
 * <p>Validates the functionality of conditional greater-than comparison instructions.</p>
 *
 * <p>Test scenarios cover various comparison conditions:</p>
 * <ul>
 *   <li>Jumping when first value is greater than the second</li>
 *   <li>Continuing sequentially when first value is not greater</li>
 *   <li>Handling equal value comparisons</li>
 * </ul>
 *
 * @author Ricki Angel
 */

public class IfCmpeqInstructionTest {
    private Machine machine;

    @BeforeEach
    void setUp() {
        machine = new Machine();
    }

    /**
     * Verifies {@link IfCmpeqInstruction} continues to the next instruction
     * when stack values are not equal. Pushes unequal values, executes, and confirms
     * the program counter does not jump to next label/instruction.
     */

    @Test
    @DisplayName("Should jump to target label when stack values are equal")
    void testShouldJumpToTargetIfValuesAreEqual() {
        Label jumpLabel = new Label("jump");
        Label returnLabel = new Label("return");

        Instruction ifEqualGotoInstruction = new IfCmpeqInstruction(null, jumpLabel);
        Instruction jumpTargetInstruction = new ReturnInstruction(jumpLabel);
        Instruction nextInstruction = new ReturnInstruction(returnLabel);

        Method mainMethod = new Method(
                new Method.Identifier("@main"),
                List.of(),
                List.of(ifEqualGotoInstruction, nextInstruction, jumpTargetInstruction)
        );
        machine.setProgram(List.of(mainMethod));
        machine.frame().push(42);
        machine.frame().push(42);

        Optional<Frame> nextFrame = ifEqualGotoInstruction.execute(machine);

        assertTrue(nextFrame.isPresent(), "Next frame should exist");
        int programCounter = nextFrame.get().programCounter();
        assertEquals(2, programCounter, "Should jump to instruction at index 2");
    }

    @Test
    @DisplayName("Should NOT jump when stack values are unequal")
    void testShouldNotJumpToTargetIfValuesAreUnequal() {
        Label jumpLabel = new Label("jump");
        Label returnLabel = new Label("return");

        Instruction ifEqualGotoInstruction = new IfCmpeqInstruction(null, jumpLabel);
        Instruction jumpTargetInstruction = new ReturnInstruction(jumpLabel);
        Instruction nextInstruction = new ReturnInstruction(returnLabel);

        Method mainMethod = new Method(
                new Method.Identifier("@main"),
                List.of(),
                List.of(ifEqualGotoInstruction, nextInstruction, jumpTargetInstruction)
        );
        machine.setProgram(List.of(mainMethod));
        machine.frame().push(99);
        machine.frame().push(2);

        Optional<Frame> nextFrame = ifEqualGotoInstruction.execute(machine);

        assertTrue(nextFrame.isPresent(), "Next frame should exist");
        int programCounter = nextFrame.get().programCounter();
        assertEquals(1, programCounter, "Should not jump to target, but continue to next instruction at index 1");
    }
}
-e \n\n===== File: ./src/test/java/sml/instructions/MulInstructionTest.java =====\n
package sml.instructions;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import sml.*;

import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * Test suite for verifying the MulInstruction's behavior in the Simple Machine Language.
 *
 * <p>Comprehensive testing of multiplication instruction functionality:</p>
 * <ul>
 *   <li>Accurate multiplication of stack-based operands</li>
 *   <li>Handling of positive and negative integer multiplication</li>
 *   <li>Correct stack manipulation during multiplication</li>
 *   <li>Ensuring proper program counter progression</li>
 * </ul>
 *
 * <p>Validates the multiplication instruction's correctness across various
 * computational scenarios and edge cases.</p>
 *
 * @author Ricki Angel
 */
public class MulInstructionTest {
    private Machine machine;

    @BeforeEach
    void setUp() {
        machine = new Machine();
        Method mainMethod = new Method(
                new Method.Identifier("@main"),
                List.of(),
                List.of(new ReturnInstruction(null))
        );
        machine.setProgram(List.of(mainMethod));
    }

    @Test
    @DisplayName("Should correctly multiply two numbers from the stack")
    void testMultiplyTwoNumbers() {
        Instruction multiplyInstruction = new MulInstruction(null);
        Instruction returnInstruction = new ReturnInstruction(null);

        Method mainMethod = new Method(
                new Method.Identifier("@main"),
                List.of(),
                List.of(multiplyInstruction, returnInstruction)
        );
        machine.setProgram(List.of(mainMethod));
        machine.frame().push(8);
        machine.frame().push(7);

        Optional<Frame> nextFrame = multiplyInstruction.execute(machine);

        int result = machine.frame().pop();
        assertEquals(56, result, "8 * 7 should equal 56");

        assertTrue(nextFrame.isPresent(), "Next frame should exist");
        assertEquals(1, nextFrame.get().programCounter(), "Program counter should advance to next instruction");
    }
}
-e \n\n===== File: ./src/test/java/sml/instructions/PrintInstructionTest.java =====\n
package sml.instructions;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import sml.*;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * Test suite for evaluating the PrintInstruction's functionality in the Simple Machine Language.
 *
 * <p>Verifies the core capabilities of the print instruction:</p>
 * <ul>
 *   <li>Extracting values from the operand stack</li>
 *   <li>Correctly outputting values to the console</li>
 *   <li>Maintaining stack integrity during print operations</li>
 * </ul>
 *
 * <p>Ensures reliable console output and stack management for 
 * debugging and program state visualization.</p>
 *
 * @author Ricki Angel
 */
public class PrintInstructionTest {
    private final ByteArrayOutputStream outContent = new ByteArrayOutputStream();

    private Machine machine;

    @BeforeEach
    void setUp() {
        machine = new Machine();
    }

    @AfterEach
    void tearDown() {
        machine = null;
    }

    @Test
    @DisplayName("Should print the top value from the stack")
    void printInstruction() {
        Instruction ins0 = new PrintInstruction(null);
        Instruction ins1 = new ReturnInstruction(null);

        Method m = new Method(new Method.Identifier("@main"),
                List.of(), List.of(ins0, ins1));
        machine.setProgram(List.of(m));
        System.setOut(new PrintStream(outContent));

        machine.frame().push(42);
        ins0.execute(machine);

        assertEquals("42\n", outContent.toString());
        System.out.println(outContent.toString());
    }
}
-e \n\n===== File: ./src/test/java/sml/instructions/AddInstructionTest.java =====\n
package sml.instructions;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import sml.*;

import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * Test suite for the AddInstruction in the Simple Machine Language.
 *
 * <p>Validates the functionality of addition instructions within the SML runtime.</p>
 *
 * <p>Test scenarios cover:</p>
 * <ul>
 *   <li>Correct addition of values from the operand stack</li>
 *   <li>Verifying stack manipulation during addition</li>
 *   <li>Ensuring correct program counter progression</li>
 * </ul>
 *
 * @author Ricki Angel
 */
public class AddInstructionTest {
    private Machine machine;

    @BeforeEach
    void setUp() {
        machine = new Machine();
    }

    // No tearDown needed - all objects will be garbage collected and no system resources were used.

    @Test
    @DisplayName("Should correctly add two numbers from the stack")
    void testExecuteAddInstruction() {
        Instruction addInstruction = new AddInstruction(null);
        Instruction returnInstruction = new ReturnInstruction(null);

        Method mainMethod = new Method(
                new Method.Identifier("@main"),
                List.of(),
                List.of(addInstruction, returnInstruction)
        );
        machine.setProgram(List.of(mainMethod));

        machine.frame().push(64);
        machine.frame().push(36);

        Optional<Frame> nextFrame = addInstruction.execute(machine);

        int result = machine.frame().pop();
        assertEquals(100, result, "64 + 36 should equal 100");

        assertTrue(nextFrame.isPresent(), "Next frame should exist");
        assertEquals(1, nextFrame.get().programCounter(), "Program counter should advance to next instruction");
    }
}
-e \n\n===== File: ./src/test/java/sml/instructions/ModInstructionTest.java =====\n
package sml.instructions;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import sml.*;
import sml.services.FileService;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collection;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Test class for the ModInstruction in the Simple Machine Language.
 *
 * <p>Verifies the correct implementation of modulo operations within the SML runtime.</p>
 *
 * <p>Key test scenarios:</p>
 * <ul>
 *   <li>Calculating remainder with different integer values</li>
 *   <li>Ensuring correct stack manipulation during modulo operations</li>
 *   <li>Validating program counter progression</li>
 * </ul>
 *
 * @author Ricki Angel
 */

public class ModInstructionTest {
    private final ByteArrayOutputStream outContent = new ByteArrayOutputStream();
    private final PrintStream originalOut = System.out;

    private Machine machine;
    private Translator translator;

    @BeforeEach
    void setUp() {
        translator = new Translator(new FileService());

        System.setOut(new PrintStream(outContent));

        machine = new Machine();
        Method mainMethod = new Method(
                new Method.Identifier("@main"),
                List.of(),
                List.of(new ReturnInstruction(null))
        );
        machine.setProgram(List.of(mainMethod));
    }

    @AfterEach
    void tearDown() {
        System.setOut(originalOut);
    }

    private String createTempSmlFile(String filename, String content) throws IOException {
        Path filePath = Files.createTempFile(filename, ".sml");
        Files.writeString(filePath, content);
        return filePath.toString();
    }

    @Test
    @DisplayName("Test modulo operation with mod opcode")
    void testModuloOperationWithModOpcode() throws IOException {
        String program = """
                @main:
                push 55
                push 9
                mod     // 55 % 9 = 1
                print
                
                push 144
                push 12
                mod     // 144 % 12 = 0
                print
                
                push 27
                push 4
                mod     // 27 % 4 = 3
                print
                
                push 0
                return
                """;

        String filePath = createTempSmlFile("modulo_test_mod_opcode.sml", program);

        Collection<Method> methods = translator.readAndTranslate(filePath);
        machine.setProgram(methods);
        machine.execute();

        String output = outContent.toString();
        assertTrue(output.contains("1"), "Result should be 1 (55 % 9)");
        assertTrue(output.contains("0"), "Result should be 0 (144 % 12)");
        assertTrue(output.contains("3"), "Result should be 3 (27 % 4)");
    }
}
-e \n\n===== File: ./src/main/java/sml/instructions/GotoInstruction.java =====\n
package sml.instructions;

import sml.*;

import java.util.Objects;

/**
 * Represents the unconditional jump instruction in the SML runtime environment.
 *
 * <p>The GotoInstruction class implements an unconditional branch operation that:</p>
 * <ul>
 *   <li>Transfers execution to a specified target label</li>
 *   <li>Requires no conditions to be evaluated</li>
 *   <li>Alters normal sequential flow of instruction execution</li>
 * </ul>
 *
 * <p>Key responsibilities:</p>
 * <ul>
 *   <li>Provides direct control flow manipulation</li>
 *   <li>Enables implementation of loops and branching structures</li>
 *   <li>Maintains program execution context during jumps</li>
 * </ul>
 *
 * @author Ricki Angel
 */
public class GotoInstruction extends Instruction {
    public static final String OP_CODE = "goto";
    private final Label branchLabel;

    /**
     * Constructs a new GotoInstruction with specified label and target.
     *
     * <p>Initializes the instruction with:</p>
     * <ul>
     *   <li>An optional source label for this instruction</li>
     *   <li>A required target label where execution will jump to</li>
     * </ul>
     *
     * @param label       The label identifying this instruction (can be null)
     * @param branchLabel The target label to jump to
     * @throws NullPointerException if branchLabel is null
     */
    public GotoInstruction(Label label, Label branchLabel) {
        super(label, OP_CODE);
        this.branchLabel = Objects.requireNonNull(branchLabel);
    }

    /**
     * Executes the instruction's primary operation.
     *
     * <p>For GotoInstruction, no computation is required during execution
     * as the instruction only affects control flow.</p>
     *
     * @param frame The current execution frame
     */
    @Override
    protected void performInstructionLogic(Frame frame) {
        // No operation needed - goto only changes control flow in determineNextFrame()
    }

    /**
     * Determines the next frame after instruction execution.
     *
     * <p>Changes the program flow by:</p>
     * <ul>
     *   <li>Locating the target instruction via the branch label</li>
     *   <li>Setting the program counter to the target instruction position</li>
     * </ul>
     *
     * @param frame The current execution frame
     * @return The modified frame with updated program counter
     */
    @Override
    protected Frame determineNextFrame(Frame frame) {
        return frame.jumpTo(branchLabel);
    }

    /**
     * Returns a string representation of the instruction's operands.
     *
     * <p>Formats the branch target label for program display and debugging.</p>
     *
     * @return String representation of the target label
     */
    @Override
    protected String getOperandsString() {
        return branchLabel.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        GotoInstruction that = (GotoInstruction) o;
        return Objects.equals(branchLabel, that.branchLabel);
    }

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), branchLabel);
    }


}
-e \n\n===== File: ./src/main/java/sml/instructions/StoreInstruction.java =====\n
package sml.instructions;

import sml.*;

/**
 * Represents the variable storage instruction in the SML runtime environment.
 *
 * <p>The StoreInstruction class implements variable assignment operations that:</p>
 * <ul>
 *   <li>Pop a value from the operand stack</li>
 *   <li>Store it in a named variable within the current frame</li>
 *   <li>Enable data persistence across instruction executions</li>
 * </ul>
 *
 * <p>Key responsibilities:</p>
 * <ul>
 *   <li>Transfers values from the operand stack to variable storage</li>
 *   <li>Manages variable state changes during execution</li>
 *   <li>Provides named access to computational results</li>
 * </ul>
 *
 * @author Ricki Angel
 */
public class StoreInstruction extends AbstractVarInstruction {
    public static final String OP_CODE = "store";

    /**
     * Constructs a new StoreInstruction with specified label and variable identifier.
     *
     * <p>Initializes the instruction with:</p>
     * <ul>
     *   <li>An optional source label for this instruction</li>
     *   <li>A required variable identifier to store to</li>
     * </ul>
     *
     * @param label   The label identifying this instruction (can be null)
     * @param varName The identifier of the variable to store into
     */
    public StoreInstruction(Label label, Variable.Identifier varName) {
        super(label, OP_CODE, varName);
    }

    /**
     * Executes the instruction's primary operation.
     *
     * <p>Performs the variable storage by:</p>
     * <ul>
     *   <li>Popping a value from the operand stack</li>
     *   <li>Locating the target variable in the current frame</li>
     *   <li>Storing the value in the variable</li>
     * </ul>
     *
     * @param frame The current execution frame
     */
    @Override
    protected void performInstructionLogic(Frame frame) {
        int value = frame.pop();
        Variable var = frame.variable(varName);
        var.store(value);
    }
}
-e \n\n===== File: ./src/main/java/sml/instructions/AddInstruction.java =====\n
package sml.instructions;

import sml.*;

/**
 * Represents an addition instruction in the SML runtime environment.
 * *
 * <p>
 * This instruction pops two operands from the stack, performs addition, and pushes the
 * computed sum back onto the stack, implementing a stack-based addition.
 * </p>
 * <p>
 * If the stack contains fewer than two elements, an error will occur, halting execution.
 * Ensure sufficient operands are present before executing this instruction.
 * </p>
 * <p>
 * The {@code performInstructionLogic} method defines the instruction's core operational logic.
 * </p>
 *
 * @author Ricki Angel
 */
public class AddInstruction extends Instruction {
    public static final String OP_CODE = "add";

    /**
     * Constructs an {@code AddInstruction} with the given label.
     *
     * @param label the label associated with this instruction
     */
    public AddInstruction(Label label) {
        super(label, OP_CODE);
    }

    /**
     * Executes the addition operation.
     * <p>
     * Pops the top two values from the stack, adds them, and pushes the result back onto the stack.
     * </p>
     *
     * @param frame the current execution frame
     */
    @Override
    protected void performInstructionLogic(Frame frame) {
        frame.push(
                frame.pop() + frame.pop()
        );
    }

    /**
     * Returns a string representation of the operands.
     *
     * @return an empty string since this instruction does not take explicit operands
     */
    @Override
    protected String getOperandsString() {
        return "";
    }
}
-e \n\n===== File: ./src/main/java/sml/instructions/NotEqInstruction.java =====\n
package sml.instructions;

import sml.*;

import java.util.Objects;

/**
 * Not Equal instruction for the SML instruction set. (supplementary - custom instruction set).
 *
 * <p>This class is an additional test mock-up instruction designed as a test case
 * for the dynamic instruction discovery system (both config and package scan). This 
 * is supplementary to the SDP coursework assignment, designed purely to enhance my 
 * familiarity with opcode and instruction discovery.</p>
 *
 * <p>The NotEqInstruction class implements a conditional branch operation that:</p>
 * <ul>
 *   <li>Pops two values from the operand stack</li>
 *   <li>Compares them for inequality</li>
 *   <li>Transfers control to a target label if the values are not equal</li>
 *   <li>Continues sequential execution otherwise</li>
 * </ul>
 *
 * <p>Key responsibilities:</p>
 * <ul>
 *   <li>Provides conditional control flow manipulation based on inequality</li>
 *   <li>Enables dynamic decision-making based on runtime values</li>
 *   <li>Supports implementation of if-then-else constructs and loops</li>
 *   <li>Demonstrates extension of the instruction set through dynamic discovery</li>
 * </ul>
 *
 * @author Ricki Angel
 */
public class NotEqInstruction extends Instruction {
    public static final String OP_CODE = "not_eq";
    private Label jumpLabel;
    private boolean shouldJump;

    /**
     * Constructs a new NotEqInstruction with only a label.
     * This constructor exists to support instruction factory testing.
     *
     * @param label The label identifying this instruction (can be null)
     */
    public NotEqInstruction(Label label) {
        super(label, OP_CODE);
    }

    /**
     * Constructs a new NotEqInstruction with specified label and jump target.
     *
     * <p>Initializes the instruction with:</p>
     * <ul>
     *   <li>An optional source label for this instruction</li>
     *   <li>A required target label for conditional branching</li>
     * </ul>
     *
     * @param label     The label identifying this instruction (can be null)
     * @param jumpLabel The target label to jump to if condition is met
     * @throws NullPointerException if jumpLabel is null
     */
    public NotEqInstruction(Label label, Label jumpLabel) {
        super(label, OP_CODE);
        this.jumpLabel = Objects.requireNonNull(jumpLabel, "Jump target label cannot be null");
    }

    /**
     * Executes the instruction's primary operation.
     *
     * <p>Performs the inequality comparison by:</p>
     * <ul>
     *   <li>Popping two values from the operand stack</li>
     *   <li>Comparing them for inequality</li>
     *   <li>Storing the comparison result for branch determination</li>
     * </ul>
     *
     * @param frame The current execution frame
     */
    @Override
    protected void performInstructionLogic(Frame frame) {
        if (jumpLabel == null) {
            int value2 = frame.pop();
            int value1 = frame.pop();
            frame.push(value1 != value2 ? 1 : 0);
        } else {
            int value2 = frame.pop();
            int value1 = frame.pop();
            shouldJump = (value1 != value2);
        }
    }

    /**
     * Determines the next frame after instruction execution.
     *
     * <p>Controls program flow by:</p>
     * <ul>
     *   <li>Jumping to the target label if values were not equal</li>
     *   <li>Advancing to the next sequential instruction otherwise</li>
     * </ul>
     *
     * @param frame The current execution frame
     * @return The next frame to execute
     */
    @Override
    protected Frame determineNextFrame(Frame frame) {
        return (jumpLabel != null && shouldJump) ? frame.jumpTo(jumpLabel) : frame.advance();
    }

    /**
     * Returns a string representation of the instruction's operands.
     *
     * <p>Formats the jump target label for program display and debugging.</p>
     *
     * @return String representation of the target label or empty if no jump target
     */
    @Override
    protected String getOperandsString() {
        return jumpLabel != null ? jumpLabel.toString() : "";
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        NotEqInstruction that = (NotEqInstruction) o;
        return Objects.equals(jumpLabel, that.jumpLabel);
    }

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), jumpLabel);
    }
}
-e \n\n===== File: ./src/main/java/sml/instructions/ReturnInstruction.java =====\n
package sml.instructions;

import sml.*;

/**
 * Represents the method return instruction in the SML runtime environment.
 *
 * <p>The ReturnInstruction class implements method termination operations that:</p>
 * <ul>
 *   <li>Pop a value from the current frame's operand stack</li>
 *   <li>Transfer this value to the invoking frame's stack</li>
 *   <li>Transfer execution control back to the calling method</li>
 * </ul>
 *
 * <p>Key responsibilities:</p>
 * <ul>
 *   <li>Manages method call termination</li>
 *   <li>Handles return value propagation between frames</li>
 *   <li>Restores execution context to the calling method</li>
 * </ul>
 *
 * @author Ricki Angel
 */
public class ReturnInstruction extends Instruction {
    public static final String OP_CODE = "return";

    /**
     * Constructs a new ReturnInstruction with the specified label.
     *
     * <p>Initializes the instruction with:</p>
     * <ul>
     *   <li>An optional source label for this instruction</li>
     *   <li>The return operation code</li>
     * </ul>
     *
     * @param label The label identifying this instruction (can be null)
     */
    public ReturnInstruction(Label label) {
        super(label, OP_CODE);
    }

    /**
     * Executes the instruction's primary operation.
     *
     * <p>Performs the return operation by:</p>
     * <ul>
     *   <li>Popping a value from the current frame's stack</li>
     *   <li>Pushing this value onto the invoking frame's stack if present</li>
     * </ul>
     *
     * @param frame The current execution frame
     */
    @Override
    protected void performInstructionLogic(Frame frame) {
        int value = frame.pop();
        frame.invoker().ifPresent(invoker -> invoker.push(value));
    }

    /**
     * Determines the next frame after instruction execution.
     *
     * <p>Controls program flow by:</p>
     * <ul>
     *   <li>Retrieving the invoking frame</li>
     *   <li>Advancing the invoker's program counter</li>
     *   <li>Returning null if there is no invoker, indicating program termination</li>
     * </ul>
     *
     * @param frame The current execution frame
     * @return The invoking frame advanced to its next instruction, or null if none
     */
    @Override
    protected Frame determineNextFrame(Frame frame) {
        return frame.invoker()
                .map(Frame::advance)
                .orElse(null);
    }

    /**
     * Returns a string representation of the instruction's operands.
     *
     * <p>Return instruction requires no additional operands beyond
     * the value obtained from the stack.</p>
     *
     * @return Empty string as this instruction has no operands
     */
    @Override
    protected String getOperandsString() {
        return "";
    }
}
-e \n\n===== File: ./src/main/java/sml/instructions/NumCharInstruction.java =====\n
package sml.instructions;

import sml.Frame;
import sml.Label;

public class NumCharInstruction extends Instruction {
    public static final String OP_CODE = "num_char";

    /**
     * Represents the NumChar instruction in the Simple Machine Language.
     *
     * <p>This class is an additional test mock-up instruction designed as a test case
     * for the dynamic instruction discovery system (package scan). It's deliberately not
     * included in the opcode_properties config file. This instruction is supplementary 
     * to the SDP coursework assignment, designed purely to enhance my familiarity with
     * opcode and instruction discovery.</p> 
     *
     * <p>The NumCharInstruction converts a number to its corresponding alphabetic character,
     * prints the result, and pushes the character's ASCII value onto the stack.
     * It extends the base {@link Instruction} class and provides the implementation
     * for executing the instruction within the SML runtime.</p>
     *
     * <p>Key responsibilities:</p>
     * <ul>
     *   <li>Popping a number from the stack</li>
     *   <li>Converting the number to its corresponding alphabetic character</li>
     *   <li>Printing the resulting character</li>
     *   <li>Pushing the character's ASCII value onto the stack</li>
     * </ul>
     *
     * <p>Execution behavior:</p>
     * <ol>
     *   <li>Retrieves the top value from the stack, expecting it to be a number</li>
     *   <li>Converts the number to its corresponding alphabetic character using the formula:
     *       <code>'A' + number - 1</code></li>
     *   <li>Prints the resulting character to the console</li>
     *   <li>Pushes the character's ASCII value onto the stack</li>
     * </ol>
     *
     * <p>Example usage:</p>
     * <pre>
     *   // Create a NumCharInstruction with an optional label
     *   Instruction numCharInstruction = new NumCharInstruction(new Label("L1"));
     *
     * @author Ricki Angel
     */
    public NumCharInstruction(Label label) {
        super(label, OP_CODE);
    }

    /**
     * Executes the NumChar instruction.

     * Pops a number from the stack, converts it to the corresponding alphabetic character,
     * prints the character, and pushes the character's ASCII value onto the stack.
     *
     * @param frame the execution frame
     */
    @Override
    protected void performInstructionLogic(Frame frame) {
        int number = frame.pop();
        char letter = (char) ('A' + number -1);
        System.out.println(letter);
        frame.push((int)letter);

    }

    @Override
    protected String getOperandsString() {
        return "";
    }
}
-e \n\n===== File: ./src/main/java/sml/instructions/PrintInstruction.java =====\n
package sml.instructions;

import sml.*;

import java.util.Optional;

/**
 * Print instruction in the SML runtime environment.
 *
 * <p>The PrintInstruction class implements output operations that:</p>
 * <ul>
 *   <li>Pop a value from the operand stack</li>
 *   <li>Display it on the console</li>
 *   <li>Support program monitoring and debugging</li>
 * </ul>
 *
 * <p>Key responsibilities:</p>
 * <ul>
 *   <li>Provides program output capabilities</li>
 *   <li>Enables runtime value inspection</li>
 *   <li>Facilitates debugging and result visualization</li>
 * </ul>
 *
 * @author Ricki Angel
 */
public class PrintInstruction extends Instruction {
    public static final String OP_CODE = "print";

    /**
     * Constructs a new PrintInstruction with the specified label.
     *
     * <p>Initializes the instruction with:</p>
     * <ul>
     *   <li>An optional source label for this instruction</li>
     *   <li>The print operation code</li>
     * </ul>
     *
     * @param label The label identifying this instruction (can be null)
     */
    public PrintInstruction(Label label) {
        super(label, OP_CODE);
    }

    /**
     * Executes the print instruction's core functionality.
     *
     * <p>Outputs the top value from the operand stack to the system console, 
     * supporting runtime program state visualization and debugging.</p>
     *
     * <p>Key output behavior:</p>
     * <ul>
     *   <li>Retrieves the topmost integer value from the execution frame's stack</li>
     *   <li>Immediately prints the value to standard output</li>
     *   <li>Supports diagnostic and monitoring capabilities during program execution</li>
     * </ul>
     *
     * <p>Utilises Optional and method reference for concise, null-safe value extraction.</p>
     *
     * @param frame The current stack-based execution context containing the value to print
     */
    @Override
    protected void performInstructionLogic(Frame frame) {
        Optional.of(frame.pop())  
                .ifPresent(System.out::println); 
    }

    /**
     * Returns a string representation of the instruction's operands.
     *
     * <p>Print instruction requires no additional operands beyond
     * the value obtained from the stack.</p>
     *
     * @return Empty string as this instruction has no operands
     */
    @Override
    protected String getOperandsString() {
        return "";
    }
}
-e \n\n===== File: ./src/main/java/sml/instructions/AbstractVarInstruction.java =====\n
package sml.instructions;

import sml.Label;
import sml.Variable;

import java.util.Objects;
import java.util.stream.Stream;

/**
 * Abstract base class for SML instructions that interact with variables.
 *
 * <p>Provides a common implementation for instructions that manipulate variables, 
 * such as load and store operations. Ensures consistent variable name management 
 * across different variable-based instruction types.</p>
 *
 * <h2>Key Responsibilities<:/h2>
 * <ul>
 *   <li>Define a standard interface for variable-based instructions</li>
 *   <li>Manage variable identifiers consistently</li>
 *   <li>Provide default implementations for equality and hash code generation</li>
 *   <li>Support stream-based variable retrieval</li>
 * </ul>
 *
 * <p>Subclasses must extend this class to inherit standard variable instruction behaviors.</p>
 *
 * @author Ricki Angel
 */
public abstract  class AbstractVarInstruction extends Instruction
       {

    /**
     * The identifier for the variable being manipulated.
     */
    protected final Variable.Identifier varName;

    /**
     * Constructs an {@code AbstractVarInstruction} with the given label, opcode, and variable name.
     *
     * @param label   the label associated with this instruction
     * @param opcode  the operation code of the instruction
     * @param varName the identifier of the variable being manipulated
     * @throws NullPointerException if {@code varName} is null
     */
    protected AbstractVarInstruction(Label label, String opcode, Variable.Identifier varName) {
        super(label, opcode);
        this.varName = Objects.requireNonNull(varName, "Variable identifier cannot be null");
    }

    /**
     * Returns a stream containing the variable involved in this instruction.
     *
     * @return a stream containing a single variable identifier
     */
    @Override
    public Stream<Variable.Identifier> variables() {
        return Stream.of(varName);
    }

    /**
     * Checks whether this instruction is equal to another object.
     *
     * @param o the object to compare
     * @return {@code true} if this instruction is equal to {@code o}, otherwise {@code false}
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        AbstractVarInstruction that = (AbstractVarInstruction) o;
        return Objects.equals(varName, that.varName);
    }

    /**
     * Computes the hash code for this instruction.
     *
     * @return the computed hash code
     */
    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), varName);
    }

    /**
     * Returns a string representation of the operand(s) for this instruction.
     *
     * @return the variable name as a string
     */
    @Override
    protected String getOperandsString() {
        return varName.toString();
    }
}
-e \n\n===== File: ./src/main/java/sml/instructions/DivInstruction.java =====\n
package sml.instructions;

import sml.*;

/**
 * Represents a Division instruction in the SML runtime environment.
 * *
 * <p>
 * This instruction performs integer division using values from the stack. It pops the
 * top two values, divides the second-to-top value by the top value, and pushes the quotient
 * back onto the stack.
 * </p>
 * <p>
 * If division by zero is attempted, an {@link ArithmeticException} is thrown.
 * </p>
 * <p>
 * The {@code performInstructionLogic} method defines the instruction's core operational logic.
 * </p>
 *
 * @author Ricki Angel
 */
public class DivInstruction extends Instruction {
    public static final String OP_CODE = "div";

    /**
     * Constructs a {@code DivInstruction} with the given label.
     *
     * @param label the label associated with this instruction
     */
    public DivInstruction(Label label) {
        super(label, OP_CODE);
    }

    /**
     * Executes the division operation.
     * <p>
     * Pops the top two values from the stack, divides the second value by the first, and
     * pushes the result back onto the stack.
     * </p>
     * <p>
     * Throws an {@link ArithmeticException} if division by zero is attempted.
     * </p>
     *
     * @param frame the current execution frame
     * @throws ArithmeticException if division by zero occurs
     */
    @Override
    protected void performInstructionLogic(Frame frame) {
        int value2 = frame.pop();
        int value1 = frame.pop();
        if (value2 == 0) {
            throw new ArithmeticException("Division by zero");
        }
        frame.push(value1 / value2);
    }

    /**
     * Returns a string representation of the operands.
     *
     * @return an empty string since this instruction does not take explicit operands
     */
    @Override
    protected String getOperandsString() {
        return "";
    }
}
-e \n\n===== File: ./src/main/java/sml/instructions/InvokeInstruction.java =====\n
package sml.instructions;

import sml.*;

import java.util.Objects;
import java.util.Optional;

/**
 * Represents the method invocation instruction in the SML runtime environment.
 *
 * <p>The InvokeInstruction class implements method call operations that:</p>
 * <ul>
 *   <li>Create a new execution frame for a target method</li>
 *   <li>Transfer operand stack values as method arguments</li>
 *   <li>Switch execution context to the invoked method</li>
 * </ul>
 *
 * <p>Key responsibilities:</p>
 * <ul>
 *   <li>Initiates method calls during program execution</li>
 *   <li>Manages execution context transitions between methods</li>
 *   <li>Supports modular program structure and reuse</li>
 * </ul>
 *
 * @author Ricki Angel
 */
public class InvokeInstruction extends Instruction {
    public static final String OP_CODE = "invoke";
    private final Method.Identifier methodName;

    /**
     * Constructs a new InvokeInstruction with specified label and method name.
     *
     * <p>Initializes the instruction with:</p>
     * <ul>
     *   <li>An optional source label for this instruction</li>
     *   <li>A required method identifier for the target method</li>
     * </ul>
     *
     * @param label      The label identifying this instruction (can be null)
     * @param methodName The identifier of the method to invoke
     * @throws NullPointerException if methodName is null
     */
    public InvokeInstruction(Label label, Method.Identifier methodName) {
        super(label, OP_CODE);
        this.methodName = Objects.requireNonNull(methodName);
    }

    /**
     * Executes the instruction's primary operation.
     *
     * <p>For InvokeInstruction, no computation is required during execution
     * as the method invocation is handled in the execute method.</p>
     *
     * @param frame The current execution frame
     */
    @Override
    protected void performInstructionLogic(Frame frame) {
        // No operations performed here - method invocation handled in execute()
    }

    /**
     * Overrides the template method to perform method invocation.
     *
     * <p>Creates a new execution frame by:</p>
     * <ul>
     *   <li>Locating the target method in the program</li>
     *   <li>Creating a new frame for the method</li>
     *   <li>Transferring operand stack values as method arguments</li>
     * </ul>
     *
     * @param machine The machine the instruction runs on
     * @return Optional containing the new method frame
     */
    @Override
    public Optional<Frame> execute(Machine machine) {
        return machine.newFrameForMethodInvocation(methodName);
    }

    /**
     * Returns a string representation of the instruction's operands.
     *
     * <p>Formats the method name with @ prefix for program display and debugging.</p>
     *
     * @return String representation of the method name
     */
    @Override
    protected String getOperandsString() {
        return "@" + methodName;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        InvokeInstruction that = (InvokeInstruction) o;
        return Objects.equals(methodName, that.methodName);
    }

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), methodName);
    }
}
-e \n\n===== File: ./src/main/java/sml/instructions/IfCmpgtInstruction.java =====\n
package sml.instructions;

import sml.*;

import java.util.Objects;

/**
 * A conditional greater-than comparison instruction.
 *
 * <p>The IfCmpgtInstruction class implements a conditional branch operation that:</p>
 * <ul>
 *   <li>Pops two values from the operand stack</li>
 *   <li>Compares if the first value is greater than the second</li>
 *   <li>Transfers control to a target label if the condition is true</li>
 *   <li>Continues sequential execution otherwise</li>
 * </ul>
 *
 * <p>Key responsibilities:</p>
 * <ul>
 *   <li>Provides conditional branching based on numeric comparison</li>
 *   <li>Enables implementation of comparison-based control structures</li>
 *   <li>Supports dynamic decision points in program execution</li>
 * </ul>
 *
 * @author Ricki Angel
 */
public class IfCmpgtInstruction extends Instruction {
    public static final String OP_CODE = "if_cmpgt";
    private final Label jumpLabel;
    private boolean shouldJump;

    /**
     * Constructs a new IfCmpgtInstruction with specified label and jump target.
     *
     * <p>Initializes the instruction with:</p>
     * <ul>
     *   <li>An optional source label for this instruction</li>
     *   <li>A required target label for conditional branching</li>
     * </ul>
     *
     * @param label     The label identifying this instruction (can be null)
     * @param jumpLabel The target label to jump to if condition is met
     */
    public IfCmpgtInstruction(Label label, Label jumpLabel) {
        super(label, OP_CODE);
        this.jumpLabel = jumpLabel;
    }

    /**
     * Executes the instruction's primary operation.
     *
     * <p>Performs the greater-than comparison by:</p>
     * <ul>
     *   <li>Popping two values from the operand stack</li>
     *   <li>Comparing if first value is greater than second</li>
     *   <li>Storing the comparison result for branch determination</li>
     * </ul>
     *
     * @param frame The current execution frame
     */
    @Override
    protected void performInstructionLogic(Frame frame) {
        int value2 = frame.pop();
        int value1 = frame.pop();
        shouldJump = (value1 > value2);
    }

    /**
     * Determines the next frame after instruction execution.
     *
     * <p>Controls program flow by:</p>
     * <ul>
     *   <li>Jumping to the target label if comparison was true</li>
     *   <li>Advancing to the next sequential instruction otherwise</li>
     * </ul>
     *
     * @param frame The current execution frame
     * @return The next frame to execute
     */
    @Override
    protected Frame determineNextFrame(Frame frame) {
        return shouldJump ? frame.jumpTo(jumpLabel) : frame.advance();
    }

    /**
     * Returns a string representation of the instruction's operands.
     *
     * <p>Formats the jump target label for program display and debugging.</p>
     *
     * @return String representation of the target label
     */
    @Override
    protected String getOperandsString() {
        return jumpLabel.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        IfCmpgtInstruction that = (IfCmpgtInstruction) o;
        return Objects.equals(jumpLabel, that.jumpLabel);
    }

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), jumpLabel);
    }
}
-e \n\n===== File: ./src/main/java/sml/instructions/LoadInstruction.java =====\n
package sml.instructions;

import sml.*;

/**
 * Represents the variable loading instruction.
 *
 * <p>The LoadInstruction class implements variable access operations that:</p>
 * <ul>
 *   <li>Locates a variable in the current execution context</li>
 *   <li>Retrieves its integer value</li>
 *   <li>Pushes the value onto the operand stack for subsequent operations</li>
 * </ul>
 *
 * <p>Key responsibilities:</p>
 * <ul>
 *   <li>Provides access to stored variable values</li>
 *   <li>Transfers data from variable storage to operand stack</li>
 *   <li>Enables computation using previously stored values</li>
 * </ul>
 *
 * @author Ricki Angel
 */
public class LoadInstruction extends AbstractVarInstruction {
    public static final String OP_CODE = "load";

    /**
     * Constructs a new LoadInstruction with specified label and variable identifier.
     *
     * <p>Initializes the instruction with:</p>
     * <ul>
     *   <li>An optional source label for this instruction</li>
     *   <li>A required variable identifier to load from</li>
     * </ul>
     *
     * @param label   The label identifying this instruction (can be null)
     * @param varName The identifier of the variable to load
     */
    public LoadInstruction(Label label, Variable.Identifier varName) {
        super(label, OP_CODE, varName);
    }

    /**
     * Executes the instruction's primary operation.
     *
     * <p>Performs the variable loading by:</p>
     * <ul>
     *   <li>Retrieving the variable from the current frame</li>
     *   <li>Loading its integer value</li>
     *   <li>Pushing the value onto the operand stack</li>
     *   <li>Displaying the loaded value for debugging</li>
     * </ul>
     *
     * @param frame The current execution frame
     */
    @Override
    protected void performInstructionLogic(Frame frame) {
        Variable var = frame.variable(varName);
        int value = var.load();
        frame.push(value);
        System.out.println(value);
    }
}
-e \n\n===== File: ./src/main/java/sml/instructions/MulInstruction.java =====\n
package sml.instructions;

import sml.*;

/**
 * A Multiplication instruction in the SML runtime environment.
 *
 * <p>The MulInstruction class implements arithmetic operations that:</p>
 * <ul>
 *   <li>Pop two integer values from the operand stack</li>
 *   <li>Multiply them together</li>
 *   <li>Push the resulting product back onto the stack</li>
 * </ul>
 *
 * <p>Key responsibilities:</p>
 * <ul>
 *   <li>Performs integer multiplication</li>
 *   <li>Manages operand stack interactions</li>
 *   <li>Supports arithmetic expression evaluation</li>
 * </ul>
 *
 * @author Ricki Angel
 */
public class MulInstruction extends Instruction {
    public static final String OP_CODE = "mul";

    /**
     * Constructs a new MulInstruction with the specified label.
     *
     * <p>Initializes the instruction with:</p>
     * <ul>
     *   <li>An optional source label for this instruction</li>
     *   <li>The multiplication operation code</li>
     * </ul>
     *
     * @param label The label identifying this instruction (can be null)
     */
    public MulInstruction(Label label) {
        super(label, OP_CODE);
    }

    /**
     * Executes the instruction's primary operation.
     *
     * <p>Performs the multiplication by:</p>
     * <ul>
     *   <li>Popping two values from the operand stack</li>
     *   <li>Multiplying them together</li>
     *   <li>Pushing the product back onto the stack</li>
     * </ul>
     *
     * @param frame The current execution frame
     */
    @Override
    protected void performInstructionLogic(Frame frame) {
        int value2 = frame.pop();
        int value1 = frame.pop();
        frame.push(Math.multiplyExact(value1, value2)); 
    }

    /**
     * Returns a string representation of the instruction's operands.
     *
     * <p>Multiplication requires no additional operands beyond
     * the values obtained from the stack.</p>
     *
     * @return Empty string as this instruction has no operands
     */
    @Override
    protected String getOperandsString() {
        return "";
    }
}
-e \n\n===== File: ./src/main/java/sml/instructions/Instruction.java =====\n
package sml.instructions;

import sml.Frame;
import sml.Label;
import sml.Machine;
import sml.Variable;

import java.util.Objects;
import java.util.Optional;
import java.util.stream.Stream;

/**
 * Represents the base instruction type in the SML runtime environment.
 *
 * <p>The Instruction class provides a common framework for all SML instructions, with:</p>
 * <ul>
 *   <li>Template method pattern for execution flow control</li>
 *   <li>Label identification and management</li>
 *   <li>Operand handling and representation</li>
 *   <li>Consistent execution semantics across instruction types</li>
 * </ul>
 *
 * <p>Key responsibilities:</p>
 * <ul>
 *   <li>Standardizes instruction execution sequence</li>
 *   <li>Manages program flow transitions between instructions</li>
 *   <li>Provides extension points for instruction-specific behavior</li>
 *   <li>Supports instruction introspection and debugging</li>
 * </ul>
 *
 * @author Ricki Angel
 */
public abstract  class Instruction  {
    protected final Label label;
    protected final String opcode;

    /**
     * Constructs a new Instruction with specified label and opcode.
     *
     * <p>Initializes the instruction with:</p>
     * <ul>
     *   <li>An optional label for branching targets</li>
     *   <li>A required operation code defining instruction type</li>
     * </ul>
     *
     * @param label  Optional label identifying this instruction location
     * @param opcode Required operation code indicating instruction type
     * @throws NullPointerException if opcode is null
     */
    public Instruction(Label label, String opcode) {
        this.label = label;
        this.opcode = Objects.requireNonNull(opcode);
    }

    /**
     * Returns an Optional containing this instruction's label.
     *
     * <p>Provides safe access to the instruction's label which may be null.</p>
     *
     * @return Optional containing the label, or empty if no label
     */
    public Optional<Label> optionalLabel() {
        return Optional.ofNullable(label);
    }

    /**
     * Returns this instruction's operation code.
     *
     * <p>The opcode uniquely identifies the instruction type in the SML system.</p>
     *
     * @return String representation of the instruction's opcode
     */
    public String opcode() {
        return opcode;
    }

    /**
     * Returns the stream of variables in the instruction's operands.
     *
     * <p>Provides access to variable identifiers referenced by this instruction.
     * Default implementation returns empty stream. Subclasses with variable
     * operands must override.</p>
     *
     * @return Stream of variable identifiers referenced by this instruction
     */
    public Stream<Variable.Identifier> variables() {
        return Stream.of();
    }

    /**
     * Executes this instruction in the given machine context.
     *
     * <p>Template method that defines execution sequence:</p>
     * <ul>
     *   <li>Performs instruction-specific execution logic</li>
     *   <li>Determines the next frame to execute</li>
     *   <li>Returns the next frame wrapped in Optional</li>
     * </ul>
     *
     * @param machine The machine the instruction runs on
     * @return Optional containing the next frame, or empty if execution terminates
     */
    public Optional<Frame> execute(Machine machine) {
        Frame frame = machine.frame();
        performInstructionLogic(frame);
        Frame nextFrame = determineNextFrame(frame);

        if (nextFrame == null) {
            // Handle this case, possibly by returning an empty Optional or logging the error:
            return Optional.empty();
        }

        return Optional.of(nextFrame);
    }

    /**
     * Performs instruction-specific execution logic.
     *
     * <p>Hook method that must be implemented by concrete subclasses
     * to provide the core behavior of the instruction.</p>
     *
     * @param frame Current execution frame
     */
    protected abstract void performInstructionLogic(Frame frame);

    /**
     * Determines the next frame after instruction execution.
     *
     * <p>Template method that controls program flow:</p>
     * <ul>
     *   <li>Default implementation advances to next sequential instruction</li>
     *   <li>Subclasses override for special flow control (jumps, returns)</li>
     * </ul>
     *
     * @param frame Current execution frame
     * @return Next frame to execute
     */
    protected Frame determineNextFrame(Frame frame) {
        return frame.advance();
    }

    /**
     * Returns a string representation of the instruction's operands.
     *
     * <p>Must be implemented by concrete subclasses to provide
     * string representation of instruction-specific operands.</p>
     *
     * @return String representation of operands
     */
    protected abstract String getOperandsString();

    /**
     * Compares this instruction with another object for equality.
     *
     * <p>Two instructions are equal if they:</p>
     * <ul>
     *   <li>Are of the same concrete class</li>
     *   <li>Have equal labels (or both have no label)</li>
     *   <li>Have equal opcodes</li>
     * </ul>
     *
     * @param o Object to compare with
     * @return true if equal, false otherwise
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Instruction that = (Instruction) o;
        return Objects.equals(label, that.label) &&
                Objects.equals(opcode, that.opcode);
    }

    /**
     * Computes a hash code for this instruction.
     *
     * <p>The hash code is based on the instruction's label and opcode.</p>
     *
     * @return Hash code value
     */
    @Override
    public int hashCode() {
        return Objects.hash(label, opcode);
    }

    /**
     * Returns a string representation of this instruction.
     *
     * <p>Format includes:</p>
     * <ul>
     *   <li>Label (if present) followed by colon</li>
     *   <li>Opcode</li>
     *   <li>String representation of operands</li>
     * </ul>
     *
     * @return String representation of the instruction
     */
    @Override
    public String toString() {
        return String.join(" ",
                optionalLabel().map(s -> s + ":").orElse(""),
                opcode(),
                getOperandsString());
    }
}
-e \n\n===== File: ./src/main/java/sml/instructions/SubInstruction.java =====\n
package sml.instructions;

import sml.*;

/**
 * A Subtraction instruction for the SML runtime environment.
 *
 * <p>The SubInstruction class implements arithmetic operations that:</p>
 * <ul>
 *   <li>Pop two integer values from the operand stack</li>
 *   <li>Subtract the second value from the first value</li>
 *   <li>Push the resulting difference back onto the stack</li>
 * </ul>
 *
 * <p>Key responsibilities:</p>
 * <ul>
 *   <li>Performs integer subtraction</li>
 *   <li>Manages operand stack interactions</li>
 *   <li>Supports arithmetic expression evaluation</li>
 * </ul>
 *
 * @author Ricki Angel
 */
public class SubInstruction extends Instruction {
    public static final String OP_CODE = "sub";

    /**
     * Constructs a new SubInstruction with the specified label.
     *
     * <p>Initializes the instruction with:</p>
     * <ul>
     *   <li>An optional source label for this instruction</li>
     *   <li>The subtraction operation code</li>
     * </ul>
     *
     * @param label The label identifying this instruction (can be null)
     */
    public SubInstruction(Label label) {
        super(label, OP_CODE);
    }

    /**
     * Executes the instruction's primary operation.
     *
     * <p>Performs the subtraction by:</p>
     * <ul>
     *   <li>Popping two values from the operand stack</li>
     *   <li>Subtracting the second value from the first value</li>
     *   <li>Pushing the difference back onto the stack</li>
     * </ul>
     *
     * @param frame The current execution frame
     */
    @Override
    protected void performInstructionLogic(Frame frame) {
        int value2 = frame.pop();
        int value1 = frame.pop();
        frame.push(value1 - value2);
    }

    /**
     * Returns a string representation of the instruction's operands.
     *
     * <p>Subtraction requires no additional operands beyond
     * the values obtained from the stack.</p>
     *
     * @return Empty string as this instruction has no operands
     */
    @Override
    protected String getOperandsString() {
        return "";
    }
}
-e \n\n===== File: ./src/main/java/sml/instructions/ModInstruction.java =====\n
package sml.instructions;

import sml.*;

/**
 * A Modulo instruction in the SML runtime environment (Supplementary).
 *
 * <p>This class is an additional test mock-up instruction designed as a test case
 * for the dynamic instruction discovery system (both config and package scan). This 
 * is supplementary to the SDP coursework assignment, designed purely to enhance my 
 * familiarity with opcode and instruction discovery.</p>
 *  
 * <p>The ModInstruction class implements arithmetic operations that:</p>
 * <ul>
 *   <li>Pop two integer values from the operand stack</li>
 *   <li>Calculate the remainder when the first value is divided by the second</li>
 *   <li>Push the resulting remainder back onto the stack</li>
 * </ul>
 *
 * <p>Key responsibilities:</p>
 * <ul>
 *   <li>Performs integer modulo operations</li>
 *   <li>Serves as a test case for the instruction factory system to test true extensibility</li>
 *   <li>Supports modular arithmetic in SML programs</li>
 *   <li>Handles error conditions like division by zero</li>
 * </ul>
 *
 * <p>Note: The modulo operation in this instruction follows Java's semantics,
 * where the sign of the result matches the sign of the dividend.</p>
 *
 * @author Ricki Angel
 */
public class ModInstruction extends Instruction {
    public static final String OP_CODE = "mod";

    /**
     * Constructs a {@code ModInstruction} with the given label.
     *
     * <p>Initializes the instruction with:</p>
     * <ul>
     *   <li>An optional source label for this instruction</li>
     *   <li>The modulo operation code</li>
     * </ul>
     *
     * @param label the label associated with this instruction (can be null)
     */
    public ModInstruction(Label label) {
        super(label, OP_CODE);
    }

    /**
     * Executes the modulo operation.
     * <p>
     * Pops the top two values from the stack, calculates the remainder when
     * the first value is divided by the second, and pushes the result back onto the stack.
     * </p>
     * <p>
     * Throws an {@link ArithmeticException} if division by zero is attempted.
     * </p>
     *
     * @param frame the current execution frame
     * @throws ArithmeticException if the divisor is zero
     */
    @Override
    protected void performInstructionLogic(Frame frame) {
        int value2 = frame.pop();
        int value1 = frame.pop();
        if (value2 == 0) {
            throw new ArithmeticException("Modulo by zero");
        }
        frame.push(value1 % value2);
    }

    /**
     * Returns a string representation of the operands.
     *
     * <p>Modulo requires no additional operands beyond
     * the values obtained from the stack.</p>
     *
     * @return Empty string as this instruction has no operands
     */
    @Override
    protected String getOperandsString() {
        return "";
    }
}
-e \n\n===== File: ./src/main/java/sml/instructions/SqrtInstruction.java =====\n
package sml.instructions;

import sml.*;

/**
 * A Square Root instruction (supplementary - custom instruction set).
 *
 * <p>This class is an additional test mock-up instruction designed as a test case
 * for the dynamic instruction discovery system (both config and package scan). This 
 * is supplementary to the SDP coursework assignment, designed purely to enhance my 
 * familiarity with opcode and instruction discovery.</p> 
 * <ul>
 *   <li>Pops an integer value from the operand stack</li>
 *   <li>Calculates its square root using Java's Math library</li>
 *   <li>Pushes the integer result back onto the stack (truncating decimal portion)</li>
 * </ul>
 *
 * <p>Key responsibilities:</p>
 * <ul>
 *   <li>Performs square root mathematical operations</li>
 *   <li>Demonstrates dynamic instruction extension capabilities</li>
 *   <li>Serves as a test case for the instruction factory system</li>
 * </ul>
 *
 * @author Ricki Angel
 */
public class SqrtInstruction extends Instruction {
    public static final String OP_CODE = "sqrt";

    /**
     * Constructs a new SqrtInstruction with the specified label.
     *
     * <p>Initializes the instruction with:</p>
     * <ul>
     *   <li>An optional source label for this instruction</li>
     *   <li>The square root operation code</li>
     * </ul>
     *
     * @param label The label identifying this instruction (can be null)
     */
    public SqrtInstruction(Label label) {
        super(label, OP_CODE);
    }

    /**
     * Executes the instruction's primary operation.
     *
     * <p>Performs the square root operation by:</p>
     * <ul>
     *   <li>Popping a value from the operand stack</li>
     *   <li>Calculating its square root</li>
     *   <li>Converting the result to an integer</li>
     *   <li>Pushing the integer result back onto the stack</li>
     * </ul>
     *
     * @param frame The current execution frame
     */
    @Override
    protected void performInstructionLogic(Frame frame) {
        int value = frame.pop();
        double result = Math.sqrt(value);
        frame.push((int) result);
    }

    /**
     * Returns a string representation of the instruction's operands.
     *
     * <p>Square root requires no additional operands beyond
     * the value obtained from the stack.</p>
     *
     * @return Empty string as this instruction has no operands
     */
    @Override
    protected String getOperandsString() {
        return "";
    }
}
-e \n\n===== File: ./src/main/java/sml/instructions/package-info.java =====\n
/**
 * The {@code sml.instructions} package defines the instruction set for the Simple Machine Language.
 * <p>
 * It includes arithmetic, branching, and stack-based operations. Each instruction extends
 * {@link sml.instructions.Instruction} and implements specific behavior within the SML execution model.
 * <p>
 * Notable instructions:
 * <ul>
 *     <li>{@link sml.instructions.AddInstruction} - Adds two values from the stack.</li>
 *     <li>{@link sml.instructions.DivInstruction} - Performs integer division.</li>
 *     <li>{@link sml.instructions.GotoInstruction} - Jumps to a specified label.</li>
 *     <li>{@link sml.instructions.InvokeInstruction} - Calls a method.</li>
 *     <li>{@link sml.instructions.LoadInstruction} - Loads a variable from memory.</li>
 *     <li>{@link sml.instructions.StoreInstruction} - Stores a value into a variable.</li>
 *     <li>{@link sml.instructions.ReturnInstruction} - Method termination operation.</li>
 * </ul>
 * <p>
 * This package forms the executable core of an SML program, as well as others...
 * <p>
 *   Also includes four supplementary test instruction classes, additional to the coursework assignment:
 * <ul>
 *     <li>{@link sml.instructions.NotEqInstruction} - Comparison instruction.</li>
 *     <li>{@link sml.instructions.SqrtInstruction} - Square root calculation instruction.</li>
 *     <li>{@link sml.instructions.ModInstruction} -  Modulo calculation instruction.</li>
 *     <li>{@link sml.instructions.NumCharInstruction} -  Number to character conversion instruction.</li>
 * </ul>
 *
 * @author Ricki Angel
 */
package sml.instructions;
-e \n\n===== File: ./src/main/java/sml/instructions/PushInstruction.java =====\n
package sml.instructions;

import sml.*;

import java.util.Objects;

/**
 * Represents the constant value loading instruction in the SML runtime environment.
 *
 * <p>The PushInstruction class implements stack operations that:</p>
 * <ul>
 *   <li>Push literal integer values onto the operand stack</li>
 *   <li>Provide immediate data for subsequent operations</li>
 *   <li>Support constant value usage in computations</li>
 * </ul>
 *
 * <p>Key responsibilities:</p>
 * <ul>
 *   <li>Introduces constant values into program execution</li>
 *   <li>Manages operand stack additions</li>
 *   <li>Supports immediate value operations</li>
 * </ul>
 *
 * @author Ricki Angel
 */
public class PushInstruction extends Instruction {
    public static final String OP_CODE = "push";
    private final int value;

    /**
     * Constructs a new PushInstruction with the specified label and value.
     *
     * <p>Initializes the instruction with:</p>
     * <ul>
     *   <li>An optional source label for this instruction</li>
     *   <li>A required integer value to push onto the stack</li>
     * </ul>
     *
     * @param label The label identifying this instruction (can be null)
     * @param value The integer value to push onto the stack
     */
    public PushInstruction(Label label, int value) {
        super(label, OP_CODE);
        this.value = value;
    }

    /**
     * Executes the instruction's primary operation.
     *
     * <p>Performs the push operation by:</p>
     * <ul>
     *   <li>Taking the instruction's constant value</li>
     *   <li>Pushing it onto the frame's operand stack</li>
     * </ul>
     *
     * @param frame The current execution frame
     */
    @Override
    protected void performInstructionLogic(Frame frame) {
        frame.push(value);
    }

    /**
     * Returns a string representation of the instruction's operands.
     *
     * <p>Formats the constant value for program display and debugging.</p>
     *
     * @return String representation of the constant value
     */
    @Override
    protected String getOperandsString() {
        return String.valueOf(value);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        PushInstruction that = (PushInstruction) o;
        return value == that.value;
    }

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), value);
    }
}
-e \n\n===== File: ./src/main/java/sml/instructions/IfCmpeqInstruction.java =====\n
package sml.instructions;

import sml.*;

import java.util.Objects;

/**
 * A conditional equality comparison instruction.
 * <p>The IfCmpeqInstruction class implements a conditional branch operation that:</p>
 * <ul>
 *   <li>Pops two values from the operand stack</li>
 *   <li>Compares them for equality</li>
 *   <li>Transfers control to a target label if the values are equal</li>
 *   <li>Continues sequential execution otherwise</li>
 * </ul>
 *
 * <p>Key responsibilities:</p>
 * <ul>
 *   <li>Provides conditional control flow manipulation</li>
 *   <li>Enables dynamic decision-making based on runtime values</li>
 *   <li>Supports implementation of if-then-else constructs</li>
 * </ul>
 *
 * @author Ricki Angel
 */
public class IfCmpeqInstruction extends Instruction {
    public static final String OP_CODE = "if_cmpeq";
    private final Label jumpLabel;
    private boolean shouldJump;

    /**
     * Constructs a new IfCmpeqInstruction with specified label and jump target.
     *
     * <p>Initializes the instruction with:</p>
     * <ul>
     *   <li>An optional source label for this instruction</li>
     *   <li>A required target label for conditional branching</li>
     * </ul>
     *
     * @param label     The label identifying this instruction (can be null)
     * @param jumpLabel The target label to jump to if condition is met
     */
    public IfCmpeqInstruction(Label label, Label jumpLabel) {
        super(label, OP_CODE);
        this.jumpLabel = jumpLabel;
    }

    /**
     * Executes the instruction's primary operation.
     *
     * <p>Performs the equality comparison by:</p>
     * <ul>
     *   <li>Popping two values from the operand stack</li>
     *   <li>Comparing them for equality</li>
     *   <li>Storing the comparison result for branch determination</li>
     * </ul>
     *
     * @param frame The current execution frame
     */
    @Override
    protected void performInstructionLogic(Frame frame) {
        int value2 = frame.pop();
        int value1 = frame.pop();
        shouldJump = (value1 == value2);
    }

    /**
     * Determines the next frame after instruction execution.
     *
     * <p>Controls program flow by:</p>
     * <ul>
     *   <li>Jumping to the target label if values were equal</li>
     *   <li>Advancing to the next sequential instruction otherwise</li>
     * </ul>
     *
     * @param frame The current execution frame
     * @return The next frame to execute
     */
    @Override
    protected Frame determineNextFrame(Frame frame) {
        return shouldJump ? frame.jumpTo(jumpLabel) : frame.advance();
    }

    /**
     * Returns a string representation of the instruction's operands.
     *
     * <p>Formats the jump target label for program display and debugging.</p>
     *
     * @return String representation of the target label
     */
    @Override
    protected String getOperandsString() {
        return jumpLabel.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        IfCmpeqInstruction that = (IfCmpeqInstruction) o;
        return Objects.equals(jumpLabel, that.jumpLabel);
    }

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), jumpLabel);
    }


}
-e \n\n===== File: ./src/main/java/sml/RunSml.java =====\n
package sml;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.stereotype.Service;
import sml.discovery.SmlConfig;

import java.io.IOException;
import java.lang.reflect.Constructor;
import java.util.Collection;

/**
 * Serves as the main entry point for executing SML programs.
 * <p>
 * This service component is responsible for orchestrating the SML execution pipeline by:
 * <ol>
 *   <li>Loading and translating SML program files (.sml) into executable {@link Method} collections</li>
 *   <li>Configuring the virtual machine with the translated program</li>
 *   <li>Initiating program execution</li>
 * </ol>
 * <p>
 * This class implements the Spring Framework's and manual Command Line dependency injection  for configuration of its
 * core dependencies. The {@link Translator} for program parsing and the {@link Machine} for program execution.
 *
 * <h2>Spring Framework Usage:</h2>
 * <pre>
 *   ApplicationContext context = new AnnotationConfigApplicationContext(SmlConfiguration.class);
 *   RunSml runner = context.getBean(RunSml.class);
 *   runner.run("path/to/program.sml");
 * </pre>
 *
 * <h2>Command Line Usage: There are two ways of running the machine via command line:</h2>
 * <h3>Method 1: Using Maven Exec Plugin</h3>
 * <pre>
 *   mvn exec:java -Dexec.mainClass="sml.RunSml" -Dexec.args="src/main/resources/test1.sml"
 * </pre>
 *
 * <h3>Method 2: Manual Classpath Configuration</h3>
 * <pre>
 *   # First, prepare the project and dependencies
 *   mvn clean package dependency:copy-dependencies
 *
 *   # Then run the application
 *   java -cp "target/classes:target/dependency/*" sml.RunSml src/main/resources/test1.sml
 * </pre>
 *
 * @author Ricki Angel
 * @see Translator
 * @see Machine
 * @see Method
 */

@Service
public class RunSml {
    private final Translator translator;
    private final Machine machine;

    @Autowired
    public RunSml(Translator translator, Machine machine) {
        this.translator = translator;
        this.machine = machine;
    }

    /**
     * Factory method for creating a RunSml instance using manual dependency injection.
     * This supports the CLI path when Spring context is not available.
     *
     * @return a new RunSml instance with manually injected dependencies
     */
    public static RunSml create() {
        return new RunSml(new Translator(), new Machine());
    }

    /**
     * Executes an SML program from the specified file.
     *
     * @param filename The path to the SML program file
     * @throws IOException If an error occurs during file reading
     */
    public void run(String filename) throws IOException {
        Collection<Method> instructions = translator.readAndTranslate(filename);
        machine.setProgram(instructions);
        machine.execute();
    }
    /**
     * Main entry point for command-line execution.
     * Attempts to use Spring DI first, falls back to reflection-based DI if Spring fails.
     *
     * @param args Command-line arguments (expects the SML file path as the first argument)
     * @throws IOException If an error occurs while reading or running the SML program file
     * @throws ReflectiveOperationException If there are issues with manual dependency injection or class instantiation
     */
    public static void main(String... args) {
        if (args.length < 1) {
            System.err.println("Usage: java sml.RunSml src/main/resources/test1.sml");
            return;
        }

        try {
            ApplicationContext context = new AnnotationConfigApplicationContext(SmlConfig.class);
            RunSml runner = context.getBean(RunSml.class);
            runner.run(args[0]);
        } catch (Exception springInitException) {
            System.out.println("Spring initialisation has failed. Falling back to manual DI");

            try {
                Constructor<RunSml> constructor = RunSml.class.getConstructor(Translator.class, Machine.class);
                Translator translator = new Translator();
                Machine machine = new Machine();
                RunSml runner = constructor.newInstance(translator, machine);
                runner.run(args[0]);
            } catch (Exception manualDiException) {
                try {
                    RunSml.create().run(args[0]);
                } catch (IOException ioException) {
                    System.err.println("Error running program: " + ioException.getMessage());
                    ioException.printStackTrace();
                }
            }
        }
    }
}
-e \n\n===== File: ./src/main/java/sml/Label.java =====\n
package sml;

import java.util.Objects;

/**
 * Represents a label in the Simple Machine Language.
 *
 * <p>A strongly-typed, immutable wrapper for label strings, ensuring
 * type safety and preventing null labels.</p>
 *
 * <p>Key Benefits:</p>
 * <ul>
 *   <li>Immutability prevents unintended modifications</li>
 *   <li>Null-safety through compact constructor</li>
 *   <li>Provides semantic meaning beyond raw strings</li>
 * </ul>
 *
 * @author Ricki Angel
 */

// Answer to Coursework Question: What are the benefits of using this record class?
//
// - Immutability & Type Safety: Prevents accidental modification and distinguishes labels from plain Strings.
// - Built-in Methods: Auto-generates `equals`, `hashCode`, and `toString`, reducing boilerplate.
// - Null-Safety**: Ensures labels are never null via this `Objects.requireNonNull(label)` method.
//
//   Comparison with `String`:
// - Using `String`: No enforced meaning, allows null values, and risks misuse.
// - Using `Label`: Stronger type distinction, enforced validity, and safer usage.
// - And of course, Recordds automatically generate equals, hashcode and toString which reduces boilerplate.
    
public record Label(String label) {
    /**
     * Ensures the label is not null during instantiation.
     *
     * @throws NullPointerException if the label is null
     */
    public Label {
        Objects.requireNonNull(label);
    }

    /**
     * Returns the string value of the label.
     *
     * @return the label as a string
     */
    public String toString() {
        return label;
    }

// Answer to Coursework Question: Do we need to override .equals and .hashCode here?

// We do not need to override equals() and hashCode(),
// as records automatically generate them.
//
//  For label comparisons in instructions:
// - Automatically ensures labels equal when string values match
// - Generates consistent hashCode() based on string value
//
// Default record implementation handles this correctly
// by using String's comparison methods.
// However, in some Instruction subclasses, overriding equals and hashCode may be necessary 
// depending if additional fields are used for equality (value, jumpLabel, methodName etc). 
// see PushInstruction or IfCmpgtInstruction or InvokeInstruction for example)
}
-e \n\n===== File: ./src/main/java/sml/Method.java =====\n
package sml;

import sml.instructions.Instruction;

import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * Represents a method in the SML program.
 *
 * <p>A method consists of a unique identifier, a list of arguments, a set of local variables,
 * and a sequence of instructions to execute.</p>
 *
 * <p>The method's identifier must start with a '@' character, and the method may contain arguments,
 * local variables, and instructions. The constructor ensures that arguments are unique, that the instructions
 * contain at least one element, and that any labels in the instructions are mapped to their respective indices.</p>
 *
 * @author Ricki Angel
 */
public class Method {
    /**
     * Represents a unique identifier for a method.
     *
     * <p>Ensures method names start with '@' and provides a string representation
     * that omits the '@' symbol when creating the identifier.</p>
     */
    public record Identifier(String name) {
        public Identifier {
            if (name.charAt(0) != '@')
                throw new IllegalArgumentException("Method identifier name must start with @");
            name = name.substring(1);
        }

        @Override
        public String toString() {
            return name;
        }
    }

    private final Identifier name;
    private final List<Variable.Identifier> arguments;
    private final Set<Variable.Identifier> localVariables;
    private final List<Instruction> instructions;
    private final SymbolTable<Label, Integer> labels;

    /**
     * Constructs a new Method instance with the specified name, arguments, and instructions.
     *
     * <p>The constructor validates that the method's arguments are unique and that the method
     * has at least one instruction. It also computes the local variables and labels associated
     * with the method based on the provided instructions.</p>
     *
     * @param name         the unique identifier for the method
     * @param arguments    the list of method arguments
     * @param instructions the sequence of instructions for the method
     * @throws IllegalArgumentException if arguments are duplicated or no instructions are provided
     */
    public Method(Identifier name, List<Variable.Identifier> arguments, List<Instruction> instructions) {
        this.name = name;
        this.arguments = List.copyOf(arguments);
        this.instructions = List.copyOf(instructions);

        Map<Variable.Identifier, Long> argumentOccurrences = this.arguments.stream()
                .collect(Collectors.groupingBy(v -> v, Collectors.counting()));

        if (argumentOccurrences.entrySet().stream().anyMatch(e -> e.getValue() > 1))
            throw new IllegalArgumentException("Duplicate arguments: " +
                    argumentOccurrences.entrySet().stream()
                            .filter(e -> e.getValue() > 1)
                            .map(Map.Entry::getKey)
                            .toList());

        this.localVariables = this.instructions.stream()
                .flatMap(Instruction::variables)
                .filter(v -> !argumentOccurrences.containsKey(v))
                .collect(Collectors.toSet());

        if (this.instructions.isEmpty())
            throw new IllegalArgumentException("No instructions found");

        this.labels = SymbolTable.of(IntStream.range(0, this.instructions.size())
                .mapToObj(idx -> this.instructions
                        .get(idx)
                        .optionalLabel()
                        .stream()
                        .map(label -> Map.entry(label, idx)))
                .flatMap(s -> s)
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)));
    }

    /**
     * Returns the unique identifier for the method.
     *
     * @return the method identifier
     */
    public Identifier name() {
        return name;
    }

    /**
     * Returns the list of instructions for the method.
     *
     * @return the list of instructions
     */
    public List<Instruction> instructions() {
        return instructions;
    }

    /**
     * Returns the symbol table of labels associated with the method's instructions.
     *
     * @return the symbol table of labels
     */
    public SymbolTable<Label, Integer> labels() {
        return labels;
    }

    /**
     * Returns the list of method arguments.
     *
     * @return the list of arguments
     */
    public List<Variable.Identifier> arguments() {
        return arguments;
    }

    /**
     * Returns the set of local variables used by the method.
     *
     * @return the set of local variables
     */
    public Set<Variable.Identifier> localVariables() {
        return localVariables;
    }

    /**
     * Returns a string representation of the method, including its name, arguments,
     * local variables, and instructions.
     *
     * @return a string representation of the method
     */
    @Override
    public String toString() {
        return String.format("Method @%s(args: %s, locals: %s, instructions: %s)",
                name,
                arguments.stream()
                        .map(Variable.Identifier::toString)
                        .collect(Collectors.joining(", ")),
                localVariables.stream()
                        .map(Variable.Identifier::toString)
                        .collect(Collectors.joining(", ")),
                instructions.stream()
                        .map(Instruction::toString)
                        .collect(Collectors.joining("; ")));
    }

    /**
     * Uses pattern matching to compare this method to another object for equality.
     *
     * <p>Checks if the provided object is an instance of the {@code Method} class,
     * and compares the method's {@code name}, {@code arguments}, and {@code instructions}
     * to determine equality.</p>
     *
     * @param obj the object to compare this method with
     * @return {@code true} if the object is a {@code Method} and has the same {@code name},
     * {@code arguments}, and {@code instructions} as this method, otherwise {@code false}
     */
    @Override
    public boolean equals(Object obj) {
        return obj instanceof Method other &&
                this.name.equals(other.name) &&
                this.arguments.equals(other.arguments) &&
                this.instructions.equals(other.instructions);
    }

    /**
     * Returns the hash code for this method.
     *
     * @return the hash code for this method
     */
    @Override
    public int hashCode() {
        return Objects.hash(name, arguments, instructions);
    }
}
-e \n\n===== File: ./src/main/java/sml/Machine.java =====\n
package sml;

import org.springframework.stereotype.Component;
import sml.instructions.Instruction;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Represents the virtual machine for SML execution.
 *
 * <p>The Machine class maintains and controls program execution state,
 * including methods, execution frames, and program flow control.
 * It serves as the runtime environment for SML programs.</p>
 *
 * @author Ricki Angel
 */
@Component
public final class Machine {
    private SymbolTable<Method.Identifier, Method> program;
    private Optional<Frame> frame;

    /**
     * Executes the loaded SML program.
     *
     * <p>Manages program execution by iterating through instructions,
     * handling frame transitions and potential execution errors.</p>
     */
    public void execute() {
        try {
            System.out.println("== Beginning program execution ==\n");

            while (frame.isPresent()) {
                Frame f = frame.get();
                Instruction instruction = f.currentInstruction();

                System.out.println("[" + f + "]  " + instruction);

                frame = instruction.execute(this);
            }

            System.out.println("\n== Ending Program Execution ==\n");
        } catch (MethodNotFoundException e) {
            System.err.println("Error: Method not found - " + e.getMessage());
        } catch (IllegalStateException e) {
            System.err.println("Error: Illegal state - " + e.getMessage());
        }
    }

    /**
     * Initialises the program by loading methods into the symbol table.
     *
     * <p>Prepares the machine for execution by converting methods
     * to a symbol table and creating an initial frame for the main method.</p>
     *
     * @param methods Collection of methods to be loaded into the program
     */
    public void setProgram(Collection<Method> methods) {
        program = SymbolTable.of(methods.stream()
                .collect(Collectors.toMap(Method::name, m -> m)));
        frame = Optional.empty();
        frame = newFrameForMethodInvocation(new Method.Identifier("@main"));
    }

    /**
     * Retrieves the current execution frame.
     *
     * <p>Returns the active execution frame.</p>
     *
     * @return The active execution frame
     */
    public Frame frame() {
        return frame.get();
    }

    /**
     * Creates a new frame for method invocation.
     *
     * <p>Manages method call stack and argument passing by locating
     * the method, creating a new execution frame, and handling
     * argument transfer from the current frame.</p>
     *
     * @param methodName Identifier of the method to invoke
     * @return Optional containing the new execution frame
     * @throws MethodNotFoundException if the specified method cannot be found in the program
     * @throws IllegalStateException if insufficient arguments are available on the stack for method invocation
     */
    public Optional<Frame> newFrameForMethodInvocation(Method.Identifier methodName) {
        Method method = program.get(methodName)
                .orElseThrow(() -> new MethodNotFoundException(methodName));

        Frame newFrame = new Frame(method, frame.orElse(null));

        if (frame.isPresent()) {
            Frame currentFrame = frame.get();
            List<Variable.Identifier> methodArguments = newFrame.method().arguments();

            if (methodArguments.size() > currentFrame.stackSize()) {
                throw new IllegalStateException("Not enough arguments on the stack for method " + methodName +
                        ". Required: " + methodArguments.size() + ", Available: " + currentFrame.stackSize());
            }

            for (int i = methodArguments.size() - 1; i >= 0; i--) {
                Variable.Identifier var = methodArguments.get(i);
                int value = currentFrame.pop();
                Variable variable = newFrame.arguments().get(var)
                        .orElseThrow(() -> new AssertionError("Variable " + var + " not found (can never happen)"));
                variable.store(value);
            }
        }
        return Optional.of(newFrame);
    }

    @Override
    public String toString() {
        if (program == null) return "No program loaded";

        int methodCount = program.values().size();
        int totalInstructions = program.values().stream()
                .mapToInt(method -> method.instructions().size())
                .sum();

        return String.format("Program: %d methods, %d total instructions",
                methodCount, totalInstructions);
    }
}
-e \n\n===== File: ./src/main/java/sml/SymbolTable.java =====\n
package sml;

import java.util.Collection;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Immutable Symbol Table for Key-Value Mappings.
 * <p>
 * A generic, immutable key-value store ensuring safe and efficient lookups with {@link Optional}-based retrieval.
 *
 * <p>Key Features:</p>
 * <ul>
 *   <li>Immutable: Prevents modification after creation.</li>
 *   <li>Safe Retrieval: Uses {@link Optional} for missing values.</li>
 *   <li>Factory Method: Ensures controlled instantiation.</li>
 * </ul>
 *
 * @param <K> the type of keys
 * @param <V> the type of values
 * @author Ricki Angel
 */
public class SymbolTable<K, V> {
    private final Map<K, V> map;

    /**
     * Constructs a new SymbolTable instance with the provided map.
     *
     * <p>Initializes the symbol table with a copy of the provided map.</p>
     *
     * @param map the map to be copied into the symbol table
     */
    private SymbolTable(Map<K, V> map) {
        this.map = Map.copyOf(map);
    }

    /**
     * Factory method to create a new SymbolTable instance from a map.
     *
     * <p>Creates a new SymbolTable using the provided map of key-value pairs.</p>
     *
     * @param <K> the type of keys
     * @param <V> the type of values
     * @param map the map containing the key-value pairs
     * @return a new SymbolTable instance
     */
    public static <K, V> SymbolTable<K, V> of(Map<K, V> map) {
        return new SymbolTable<>(map);
    }

    /**
     * Retrieves the value associated with the given key from the symbol table.
     *
     * <p>Returns an {@link Optional} containing the value if found, or an empty {@link Optional} if the key is not present.</p>
     *
     * @param key the key to look up
     * @return an {@link Optional} containing the value if found, or an empty {@link Optional} if not
     */
    public Optional<V> get(K key) {
        return Optional.ofNullable(map.get(key));
    }

    /**
     * Returns a collection of all values stored in the symbol table.
     *
     * <p>This method returns all values present in the symbol table.</p>
     *
     * @return a collection of values
     */
    public Collection<V> values() {
        return map.values();
    }

    /**
     * Checks whether the symbol table is empty.
     *
     * <p>Returns {@code true} if the symbol table has no entries, otherwise {@code false}.</p>
     *
     * @return {@code true} if the symbol table is empty, {@code false} otherwise
     */
    public boolean isEmpty() {
        return map.isEmpty();
    }

    /**
     * Returns a string representation of the symbol table.
     *
     * <p>Provides a formatted string representation of all key-value pairs in the table.</p>
     *
     * @return a string representation of the symbol table
     */
    @Override
    public String toString() {
        return map.entrySet().stream()
                .map(entry -> entry.getKey() + " -> " + entry.getValue())
                .collect(Collectors.joining(", ", "[", "]"));
    }
}
-e \n\n===== File: ./src/main/java/sml/config/package-info.java =====\n
/**
 * Provides Spring configuration for the Simple Machine Language application.
 * <p>
 * This package contains configuration classes that set up the Spring application context:
 * <ul>
 *   <li>{@link sml.discovery.SmlConfig} - Primary configuration with component scanning and bean definitions</li>
 * </ul>
 * </p>
 * <p>
 * The configuration enables:
 * <ul>
 *   <li>Component scanning across the entire SML application</li>
 *   <li>Dependency injection for core components</li>
 *   <li>Service registration with appropriate scopes</li>
 *   <li>Logger configuration with primary bean definitions</li>
 * </ul>
 * </p>
 * <p>
 * This package supports both Spring-managed and manual dependency injection modes,
 * allowing the SML application to run with or without a Spring context.
 * </p>
 *
 * @author Ricki Angel
 * @see sml.helperfiles.InstructionRegistrationLogger
 * @see sml.helperfiles.DefaultInstructionRegistrationLogger
 */
package sml.config;
-e \n\n===== File: ./src/main/java/sml/Frame.java =====\n
package sml;

import sml.instructions.Instruction;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Represents the execution context for a method in the SML runtime environment.
 *
 * <p>The Frame class manages the complete state of a method during its execution, including:</p>
 * <ul>
 *   <li>Program counter tracking</li>
 *   <li>Method arguments and local variables</li>
 *   <li>Operand stack management</li>
 *   <li>Instruction execution context</li>
 * </ul>
 *
 * <p>Key responsibilities:</p>
 * <ul>
 *   <li>Tracks the current execution point within a method</li>
 *   <li>Provides access to method-specific variables</li>
 *   <li>Manages a stack for intermediate computational values</li>
 *   <li>Supports method invocation and context switching</li>
 * </ul>
 *
 * @author Ricki Angel
 */
public class Frame {
    private final Method method;
    private int programCounter;

    private final SymbolTable<Variable.Identifier, Variable> arguments;
    private final SymbolTable<Variable.Identifier, Variable> localVariables;
    private final Deque<Integer> stack;
    private final Frame invoker;

    // Answer to Coursework Question: 3 data structures and mutable components.
    // Explain what parts of the data structure are mutable (and what are the mutator methods).

    // 1. SymbolTable<Variable.Identifier, Variable> arguments:
    //    - A Map data sctructure which stores method args.
    //    - Modified through Variable's mutator methods.
    //    - Can modify individual variable values
    //    - The table itself is final (cannot be reassigned)

    // 2. SymbolTable<Variable.Identifier, Variable> localVariables:
    //    - Again, a Map DS which stores local variables.
    //    - Modified through Variable's mutator methods.
    //    - Can modify individual variable values
    //    - The table itself is final (cannot be reassigned)

    // 3. Deque<Integer> stack:
    //   - Mutable structure (elements can be added/removed) - double-ended?.
    //   - Modified by push() and pop() methods.
    //   - The stack itself is final (cannot be reassigned)

    // TO Clarify, the mutable components are:  
    // programCounter: (int)  Mutable (modified by setProgramCounter(int))  
    // arguments: (SymbolTable<Variable.Identifier, Variable>)  Mutable if Variable is mutable  
    // localVariables: (SymbolTable<Variable.Identifier, Variable>)  Mutable if Variable is mutable  
    // stack: (Deque<Integer>)  Mutable (modified by push(int) and pop())  

    /**
     * Constructs a new Frame for a specific method.
     *
     * <p>Initializes the frame with:</p>
     * <ul>
     *   <li>Method-specific arguments</li>
     *   <li>Local variables</li>
     *   <li>Empty operand stack</li>
     *   <li>Tracking of the invoking frame</li>
     * </ul>
     *
     * @param method  The method to be executed in this frame
     * @param invoker The frame that invoked this method (can be null)
     * @throws NullPointerException if method is null
     */

    public Frame(Method method, Frame invoker) {
        this.method = Objects.requireNonNull(method);
        this.programCounter = 0;

        this.arguments = SymbolTable.of(method.arguments().stream()
                .collect(Collectors.toMap(v -> v, v -> new Variable())));
        this.localVariables = SymbolTable.of(method.localVariables().stream()
                .collect(Collectors.toMap(v -> v, v -> new Variable())));
        this.stack = new ArrayDeque<>();

        this.invoker = invoker;
    }

    /**
     * Advances the program counter to the next instruction in the method.
     *
     * @return The next frame if another instruction exists, or null if no more instructions are available
     * @throws IndexOutOfBoundsException if the program counter exceeds the method's instruction list
     */
    public Frame advance() {
        return Optional.of(programCounter + 1)
                .filter(pc -> pc < method.instructions().size())
                .map(this::setProgramCounter)
                .orElse(null);
    }

    /**
     * Jumps to a specific labeled instruction within the current method.
     *
     * @param label The target instruction label to jump to
     * @return The frame positioned at the labeled instruction
     * @throws LabelNotFoundException if the specified label cannot be found in the method
     */

    public Frame jumpTo(Label label) {
        Optional<Integer> pc = method.labels().get(label);
        if (pc.isEmpty())
            throw new LabelNotFoundException(label, method);

        return setProgramCounter(pc.get());
    }

    /**
     * Sets the program counter to a specific instruction index within the method.
     *
     * <p>Updates the current execution point and validates the new index
     * against the method's total number of instructions.</p>
     *
     * @param programCounter The new index to set as the current program counter
     * @return The current frame with updated program counter
     * @throws IndexOutOfBoundsException if the program counter is outside
     *                                   the valid range of method instructions
     */

    private Frame setProgramCounter(int programCounter) {
        this.programCounter = programCounter;
        Objects.checkIndex(programCounter, method.instructions().size());
        return this;
    }

    public Method method() {
        return method;
    }

    public Instruction currentInstruction() {
        return method.instructions().get(programCounter);
    }

    public int programCounter() {
        return programCounter;
    }

    public Optional<Frame> invoker() {
        return Optional.ofNullable(invoker);
    }

    /**
     * Retrieves a variable from local or argument scopes based on its identifier.
     *
     * @param identifier The unique identifier of the variable to retrieve
     * @return The variable associated with the given identifier
     * @throws VariableNotFoundException if no variable matches the identifier
     */

    public Variable variable(Variable.Identifier identifier) {
        return localVariables.get(identifier)
                .or(() -> arguments.get(identifier))
                .orElseThrow(() -> new VariableNotFoundException(identifier));
    }

    public SymbolTable<Variable.Identifier, Variable> arguments() {
        return arguments;
    }

    public SymbolTable<Variable.Identifier, Variable> localVariables() {
        return localVariables;
    }

    /**
     * Removes and returns the top value from the operand stack.
     *
     * @return The integer value at the top of the stack
     * @throws NoSuchElementException if the stack is empty
     */
    public int pop() {
        if (stack.isEmpty()) {
            throw new NoSuchElementException("Cannot pop from an empty stack in method " + method.name());
        }
        return stack.pop();
    }

    /**
     * Pushes a new integer value onto the top of the operand stack.
     *
     * @param value The integer value to push onto the stack
     */
    public void push(int value) {
        stack.push(value);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(method.name())
                .append(":").append(programCounter);

        if (invoker != null) {
            Frame current = invoker;
            sb.append(" < ");
            while (current != null) {
                sb.append(current.method.name())
                        .append(":").append(current.programCounter);
                current = current.invoker;
                if (current != null) {
                    sb.append("  ");
                }
            }
        }

        return sb.toString();
    }
    
    public int stackSize() {
        return stack.size();
    }
}
-e \n\n===== File: ./src/main/java/sml/discovery/ConfigDiscovery.java =====\n
package sml.discovery;

import sml.helperfiles.InstructionRegistrationLogger;
import sml.instructions.Instruction;
import sml.registry.InstructionRegistry;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Modifier;
import java.util.Optional;
import java.util.Properties;
import java.util.function.Predicate;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Discovers and registers SML instructions dynamically from a configuration file.
 *
 * <p>This class implements a strategy for runtime instruction discovery by:</p>
 * <ul>
 *   <li>Reading instruction mappings from a properties file</li>
 *   <li>Validating and registering instruction classes</li>
 *   <li>Supporting extensible instruction set configuration</li>
 * </ul>
 *
 * @author Ricki Angel
 */
public class ConfigDiscovery implements InstructionDiscoveryStrategy {
    private static final Logger LOGGER = Logger.getLogger(ConfigDiscovery.class.getName());
    private static final String CONFIG_FILE = "config/opcode.properties";
private final InstructionRegistrationLogger logger;

    /**
     * Constructs a new ConfigDiscovery discovery method.
     *
     * @param logger The logger to use for tracking registration events.
     */
    public ConfigDiscovery(InstructionRegistrationLogger logger) {
        this.logger = logger;
    }

    /**
     * Gets the configuration resource as an input stream.
     *
     * @param configFile The path to the configuration file
     * @return An input stream for the resource, or null if not found
     */
    protected InputStream getConfigResource(String configFile) {
        return getClass().getClassLoader().getResourceAsStream(configFile);
    }

    /**
     * Discovers and registers instructions from the configuration file.
     *
     * <p>Attempts to load instruction mappings from a properties file, 
     * validating and registering each instruction class found.</p>
     *
     * @param registry The instruction registry to populate with discovered instructions
     * @return Number of successfully registered instructions
     * @throws RuntimeException if there are issues reading the configuration file
     */
    @Override
    public int discoverInstructions(InstructionRegistry registry) {

        LOGGER.log(Level.INFO, "Discovering instructions from configuration file: " + CONFIG_FILE);
        int initialSize = registry.size();

        try (InputStream input = getConfigResource(CONFIG_FILE)) {
            if (input == null) {
                LOGGER.log(Level.WARNING, "Configuration file not found: " + CONFIG_FILE);
                return 0;
            }

            Properties opProperties = new Properties();
            opProperties.load(input);

            if (opProperties.isEmpty()) {
                LOGGER.log(Level.WARNING, "Configuration file is empty: " + CONFIG_FILE);
                return 0;
            }

            int registered = 0;
            for (String opcode : opProperties.stringPropertyNames()) {
                String className = opProperties.getProperty(opcode);
                try {
                    Class<?> clazz = Class.forName(className);
                    if (registerClass(registry, clazz, opcode)) {
                        registered++;
                    }
                } catch (ClassNotFoundException e) {
                    logger.trackFailedRegistration(className, "Class not found");
                    LOGGER.log(Level.WARNING, "Class not found: " + className);
                }
            }

            LOGGER.log(Level.INFO, "Registered " + registered + " instructions from configuration file");
            return registered;

        } catch (IOException e) {
            LOGGER.log(Level.WARNING, "Error loading configuration file: " + e.getMessage(), e);
            return 0;
        }
    }

    /**
     * Validates and registers a single instruction class into the instruction registry.
     *
     * <p>This method performs a comprehensive validation of instruction classes before registration, 
     * ensuring only valid and usable instruction implementations are added to the registry.</p>
     *
     * <p>Validation criteria include:</p>
     * <ul>
     *   <li>Must be a subclass of {@link Instruction}</li>
     *   <li>Must not be an abstract class</li>
     *   <li>Must be able to be registered with the provided opcode</li>
     * </ul>
     *
     * <p>Registration process:</p>
     * <ul>
     *   <li>Logs initial registration attempt</li>
     *   <li>Performs type and modifiability checks</li>
     *   <li>Registers successful instruction classes</li>
     *   <li>Tracks registration outcomes</li>
     * </ul>
     *
     * <p>Usage:</p>
     * <ol>
     *   <li>Add a new opcode name and instruction class to the {@code /sml/config/opcode.properties} file in the format: {@code opcode=sml.instructions.InstructionClass}</li>
     *   <li>Create the instruction class and place it in the {@code sml.instructions} package. Ensure that it extends the {@link Instruction} interface.</li>
     *   <li>The new instruction will be automatically discovered and registered during the application startup.</li>
     * </ol>
     *
     * <p>Example {@code opcode.properties} entry:</p>
     * <pre>
     * sqrt=sml.instructions.SqrtInstruction
     * </pre>
     *
     * <p>Visual representation of the registration process:</p>
     * <p>
     * {@code <img src="path/to/registration-process.jpg" alt="Instruction registration process">}
     * </p>
     *
     * @param registry The instruction registry where the class will be potentially registered
     * @param clazz The instruction class candidate for registration
     * @param configOpcode The operation code associated with the instruction
     * @return {@code true} if the instruction class passes validation and is successfully registered,
     *         {@code false} if validation fails or registration cannot be completed
     *
     * @see InstructionRegistry
     * @see Instruction
     */
    private boolean registerClass(InstructionRegistry registry, Class<?> clazz, String configOpcode) {
        logger.logRegistrationAttempt(clazz);

        Predicate<Class<?>> isInstruction = c -> Instruction.class.isAssignableFrom(c);
        Predicate<Class<?>> isNotAbstract = c -> !Modifier.isAbstract(c.getModifiers());

        return Optional.of(clazz)
                .filter(isInstruction)
                .filter(isNotAbstract)
                .map(c -> (Class<? extends Instruction>) c)
                .map(instructionClass -> {
                    registry.register(configOpcode, instructionClass);
                    logger.trackSuccessfulRegistration(clazz.getSimpleName(), configOpcode);
                    return true;
                })
                .orElseGet(() -> {
                    logger.trackFailedRegistration(clazz.getSimpleName(),
                            !isInstruction.test(clazz)
                                    ? "Not an Instruction subclass"
                                    : "Abstract class");
                    return false;
                });
    }
    @Override
    public String getName() {
        return "Configuration File";
    }
}
-e \n\n===== File: ./src/main/java/sml/discovery/SmlConfig.java =====\n
package sml.discovery;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import sml.helperfiles.DefaultInstructionRegistrationLogger;
import sml.helperfiles.InstructionRegistrationLogger;

/**
 * Configuration class for the Simple Machine Language (SML) application.
 * <p>
 * This configuration provides Spring framework setup and bean definitions
 * for the SML application, enabling component scanning and defining
 * essential application beans.
 * </p>
 *
 * <h2>Key Configuration Features</h2>
 * <ul>
 *     <li>Enables component scanning across the entire SML project</li>
 *     <li>Configures the primary {@link InstructionRegistrationLogger} implementation</li>
 * </ul>
 *
 * <p>
 * The {@link #instructionRegistrationLogger()} method provides the primary
 * bean for tracking instruction registrations throughout the application.
 * </p>
 *
 * @author Ricki Angel
 * @version 1.0
 * @since 1.0
 */
@Configuration
@ComponentScan(basePackages = "sml")
public class SmlConfig {

    /**
     * Creates the primary {@link InstructionRegistrationLogger} bean.
     * <p>
     * This method instantiates the default implementation of the
     * instruction registration logger, which will be used as the
     * primary logging mechanism for instruction registrations.
     * </p>
     *
     * @return A {@link DefaultInstructionRegistrationLogger} instance
     */
    @Bean
    @Primary
    public InstructionRegistrationLogger instructionRegistrationLogger() {
        return new DefaultInstructionRegistrationLogger();
    }
}
-e \n\n===== File: ./src/main/java/sml/discovery/InstructionDiscoveryStrategy.java =====\n
package sml.discovery;

import sml.registry.InstructionRegistry;

/**
 * Strategy interface for discovering instruction classes.
 * <p>
 * Implementations of this interface provide different ways to discover
 * and register SML instruction classes.
 * </p>
 *
 * @author Ricki Angel
 */
public interface InstructionDiscoveryStrategy {

    /**
     * Strategy interface for discovering instruction classes.
     * <p>
     * Implementations of this interface provide different ways to discover
     * and register SML instruction classes. The interface defines the contract
     * for discovering instructions at runtime and registering them with the
     * provided registry.
     * </p>
     *
     * <p>
     * This interface is implemented by two concrete strategies:
     * <ul>
     *   <li>ConfigDiscovery - Discovers instructions from configuration properties file</li>
     *   <li>PackageScanDiscovery - Discovers instructions by scanning package directories</li>
     * </ul>
     * </p>
     *
     * @author Ricki Angel
     */
    int discoverInstructions(InstructionRegistry registry);

    /**
     * Returns the name of this discovery method.
     *
     * @return A descriptive name for this method
     */
    String getName();
}
-e \n\n===== File: ./src/main/java/sml/discovery/PackageScanDiscovery.java =====\n
package sml.discovery;

import sml.helperfiles.InstructionRegistrationLogger;
import sml.instructions.Instruction;
import sml.registry.InstructionRegistry;

import java.io.File;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Discovers and registers SML instructions dynamically by scanning package directories.
 * <p>
 * This class implements a strategy for runtime instruction discovery by:
 * <ul>
 *   <li>Examining the classes in the SML instructions package</li>
 *   <li>Identifying classes that implement the Instruction interface</li>
 *   <li>Registering those that meet the criteria for being a valid instruction</li>
 * </ul>
 * </p>
 *
 * <h2>Usage</h2>
 * <p>
 * To add a new instruction type:
 * <ol>
 *   <li>Create a new class in the instructions directory</li>
 *   <li>Implement the Instruction interface</li>
 *   <li>Define a static OP_CODE field with the opcode string</li>
 *   <li>Implement the required constructor and methods</li>
 * </ol>
 * The package scanning mechanism will automatically discover and register the new instruction
 * without requiring modifications to the factory code.
 * </p>
 *
 * @author Ricki Angel
 */
public class PackageScanDiscovery implements InstructionDiscoveryStrategy {
    private static final Logger LOGGER = Logger.getLogger(PackageScanDiscovery.class.getName());
    private static final String PACKAGE_NAME = "sml.instructions";

    private final InstructionRegistrationLogger logger;

    /**
     * Constructs a new PackageScanDiscovery discovery method.
     *
     * @param logger The logger to use for tracking registration events.
     */
    public PackageScanDiscovery(InstructionRegistrationLogger logger) {
        this.logger = logger;
    }

    /**
     * Discovers and registers instruction classes by scanning the package directory.
     * <p>
     * This implementation searches for class files in the SML instructions package directory,
     * loads each class, and attempts to register those that:
     * <ul>
     *   <li>Are subclasses of {@link Instruction}</li>
     *   <li>Are not abstract classes</li>
     *   <li>Contain a static {@code OP_CODE} field</li>
     *   <li>Have an opcode that hasn't already been registered</li>
     * </ul>
     * </p>
     * <p>
     * The method logs detailed information about the discovery process,
     * including warnings for missing directories and registration failures.
     * </p>
     *
     * @param registry The registry to register discovered instructions with
     * @return The number of newly registered instructions, or 0 if discovery fails
     * @throws RuntimeException If a severe error occurs during the scanning process
     */
   
    @Override
    public int discoverInstructions(InstructionRegistry registry) {
        LOGGER.log(Level.INFO, "Discovering instructions by package scanning in: " + PACKAGE_NAME);
        int initialSize = registry.size();
        int registered = 0;

        try {
            String packagePath = PACKAGE_NAME.replace('.', '/');
            String rootPath = System.getProperty("user.dir");
            String classesPath = rootPath + "/target/classes/" + packagePath;
            File packageDir = new File(classesPath);

            if (!packageDir.exists()) {
                LOGGER.log(Level.WARNING, "Package directory not found: " + classesPath);
                return 0;
            }

            File[] classFiles = packageDir.listFiles(
                    file -> file.isFile() && file.getName().endsWith(".class")
                            && !file.getName().equals("package-info.class")
            );

            if (classFiles == null) {
                LOGGER.log(Level.WARNING, "No class files found in package directory");
                return 0;
            }

            for (File classFile : classFiles) {
                String className = classFile.getName().replace(".class", "");
                String fullClassName = PACKAGE_NAME + "." + className;
                try {
                    Class<?> clazz = Class.forName(fullClassName);
                    if (registerClass(registry, clazz)) {
                        registered++;
                    }
                } catch (ClassNotFoundException e) {
                    LOGGER.log(Level.FINE, "Error loading class: " + fullClassName, e);
                }
            }

            LOGGER.log(Level.INFO, "Registered " + registered + " instructions by package scanning");
            return registered;

        } catch (Exception e) {
            LOGGER.log(Level.WARNING, "Package scanning failed: " + e.getMessage(), e);
            return 0;
        }
    }

    /**
     * Registers a class as an instruction if it meets all required criteria.
     * <p>
     * The method performs validation checks to ensure the class:
     * <ul>
     *   <li>Is a subclass of {@link Instruction}</li>
     *   <li>Is not an abstract class</li>
     *   <li>Has a static OP_CODE field</li>
     *   <li>Has an opcode that isn't already registered</li>
     * </ul>
     * </p>
     * <p>
     * All registration attempts, successful or failed, are tracked by the logger.
     * </p>
     *
     * @param registry The registry to register the instruction with
     * @param clazz The class to evaluate and potentially register
     * @return {@code true} if registration was successful, {@code false} otherwise
     */

    private boolean registerClass(InstructionRegistry registry, Class<?> clazz) {
        logger.logRegistrationAttempt(clazz);

        if (!Instruction.class.isAssignableFrom(clazz)) {
            logger.trackFailedRegistration(clazz.getSimpleName(), "Not an Instruction subclass");
            return false;
        }

        if (java.lang.reflect.Modifier.isAbstract(clazz.getModifiers())) {
            LOGGER.log(Level.FINEST, "Skipping abstract class: " + clazz.getName());
            return false;
        }

        try {
            String opcode = (String) clazz.getDeclaredField("OP_CODE").get(null);

            if (registry.isRegistered(opcode)) {
                LOGGER.log(Level.FINE, "Opcode already registered: " + opcode);
                return false;
            }

            @SuppressWarnings("unchecked")
            Class<? extends Instruction> instructionClass = (Class<? extends Instruction>) clazz;
            registry.register(opcode, instructionClass);
            logger.trackSuccessfulRegistration(clazz.getSimpleName(), opcode);
            return true;
        } catch (NoSuchFieldException e) {
            logger.trackFailedRegistration(clazz.getSimpleName(), "Missing OP_CODE field");
            return false;
        } catch (Exception e) {
            logger.trackFailedRegistration(clazz.getSimpleName(), "Registration error: " + e.getMessage());
            return false;
        }
    }
    /**
     * Returns the descriptive name of this discovery strategy.
     * <p>
     * This name is used for logging and reporting purposes to identify
     * which discovery mechanism successfully registered instructions.
     * </p>
     *
     * @return The string "Package Scanning" as the strategy identifier
     */

    @Override
    public String getName() {
        return "Package Scanning";
    }
}
-e \n\n===== File: ./src/main/java/sml/discovery/package-info.java =====\n
/**
 * Provides discovery mechanisms for dynamically loading SML instructions at runtime.
 *
 * <p>This package contains strategy implementations for discovering and registering 
 * instruction classes in the SML virtual machine. It enables extensibility through:</p>
 * <ul>
 *   <li>{@link sml.discovery.ConfigDiscovery} - Loads instructions from configuration files</li>
 *   <li>{@link sml.discovery.PackageScanDiscovery} - Discovers instructions by scanning package directories</li>
 *   <li>{@link sml.discovery.InstructionDiscoveryStrategy} - Common interface for discovery implementations</li>
 * </ul>
 *
 * <p>These discovery mechanisms allow the SML system to be extended with new instructions
 * without modifying the core codebase. New instructions can be added by:</p>
 * <ol>
 *   <li>Creating a new class that extends {@link sml.instructions.Instruction}</li>
 *   <li>Adding configuration entries or placing the class in the appropriate package</li>
 * </ol>
 *
 * <p>The discovery system supports dependency injection through the Spring Framework
 * and provides detailed logging of the discovery process.</p>
 *
 * @author Ricki Angel
 * @see sml.registry.InstructionRegistry
 * @see sml.instructions.Instruction
 *
 * <p><b>Video Tutorials:</b></p>
 * <table>
 *   <tr>
 *     <th align="center">Config Registration Process</th>
 *     <th align="center">Package Scan Process</th>
 *   </tr>
 *   <tr>
 *     <td align="center">
 *       <a href="https://youtu.be/4jjzWDJ21As" target="_blank">
 *          <img src="doc-files/config_process.jpg" alt="Configuration Registration Process Video" width="380">
 *       </a>
 *       <br>
 *       <em>Click to watch Config Registration Process</em>
 *     </td>
 *     <td align="center">
 *       <a href="https://youtu.be/PHcSX3sMAlU" target="_blank">
 *          <img src="doc-files/package_scan_process.jpg" alt="Configuration Registration Process Video" width="380">
 *       </a>
 *       <br>
 *       <em>Click to watch Package Scan Process</em>
 *     </td>
 *   </tr>
 * </table>
 */


package sml.discovery;
-e \n\n===== File: ./src/main/java/sml/MethodNotFoundException.java =====\n
package sml;

/**
 * Exception thrown when a method is not found.
 *
 * <p>This exception is typically used when attempting to access or execute a method that
 * doesn't exist or hasn't been defined in the SML program.</p>
 */
public class MethodNotFoundException extends RuntimeException {

    /**
     * Constructs a new {@code MethodNotFoundException} with a detailed message.
     *
     * @param method the identifier of the method that could not be found
     */
    public MethodNotFoundException(Method.Identifier method) {
        super("Method not found: " + method);
    }
}
-e \n\n===== File: ./src/main/java/sml/Variable.java =====\n
package sml;

import java.util.Objects;

/**
 * Represents a variable in the Simple Machine Language.
 *
 * <p>A variable is identified by its name and can store and retrieve integer values. The variable's
 * name is managed by the nested {@link Identifier} record, ensuring the name is non-null and unique.
 * The variable can store an integer value using the {@code store} method and load the stored value using
 * the {@code load} method.</p>
 *
 * @author Ricki Angel
 * @version 1.0
 */
public class Variable {
    /**
     * Represents the identifier for a variable.
     *
     * <p>This nested record encapsulates the variable's name and ensures that the name is non-null. The name
     * provides a unique identifier for the variable.</p>
     *
     * @param name The unique name of the variable
     */
    public record Identifier(String name) {
        /**
         * Canonical constructor that ensures the variable name is not null.
         *
         * @throws NullPointerException if the name is null
         */
        public Identifier {
            Objects.requireNonNull(name);
        }

        /**
         * Returns a string representation of the variable's name.
         *
         * @return The name of the variable
         */
        @Override
        public String toString() {
            return name;
        }
    }

    /**
     * The current integer value stored in the variable.
     * Initialized to 0 by default.
     */
    private int value;

    /**
     * Stores a new integer value in the variable.
     *
     * @param value The integer value to be stored
     */
    public void store(int value) {
        this.value = value;
    }

    /**
     * Retrieves the current value stored in the variable.
     *
     * @return The current integer value of the variable
     */
    public int load() {
        return value;
    }
}
-e \n\n===== File: ./src/main/java/sml/helperfiles/InstructionRegistrationLogger.java =====\n
package sml.helperfiles;

/**
 * Defines a contract for logging and tracking instruction class registration processes
 * in the Simple Machine Language system.
 * <p>
 * This interface provides methods for monitoring the registration of instruction classes,
 * capturing both successful and failed registration attempts, and generating a
 * comprehensive summary of the registration process.
 * </p>
 *
 * <h2>Key Responsibilities</h2>
 * <ul>
 *     <li>Log initial registration attempts</li>
 *     <li>Track successful instruction registrations</li>
 *     <li>Record reasons for failed registrations</li>
 *     <li>Generate a detailed registration summary</li>
 * </ul>
 *
 * <p>
 * Implementations of this interface are expected to provide concrete logging
 * mechanisms for tracking instruction class registration in the SML system.
 * </p>
 *
 * @author Ricki Angel
 * @version 1.0
 * @see DefaultInstructionRegistrationLogger
 * @since 1.0
 */
public interface InstructionRegistrationLogger {
    /**
     * Logs an attempt to register an instruction class.
     * <p>
     * This method is called when the system begins the process of registering
     * a new instruction class, allowing for initial tracking of registration attempts.
     * </p>
     *
     * @param clazz The instruction class being registered
     */
    void logRegistrationAttempt(Class<?> clazz);

    /**
     * Tracks a successful instruction registration.
     * <p>
     * Records details of an instruction that has been successfully registered,
     * including its name and associated opcode.
     * </p>
     *
     * @param instructionName The name of the successfully registered instruction
     * @param opcode          The unique operation code associated with the instruction
     */
    void trackSuccessfulRegistration(String instructionName, String opcode);

    /**
     * Tracks a failed instruction registration attempt.
     * <p>
     * Captures details of an instruction that could not be registered,
     * including the reason for the registration failure.
     * </p>
     *
     * @param instructionName The name of the instruction that failed to register
     * @param reason          Explanation for why the registration attempt failed
     */
    void trackFailedRegistration(String instructionName, String reason);

    /**
     * Generates and outputs a comprehensive summary of the instruction registration process.
     * <p>
     * Provides a detailed report of:
     * <ul>
     *     <li>Successfully registered instructions</li>
     *     <li>Failed registration attempts</li>
     *     <li>Total count of registrations</li>
     * </ul>
     * </p>
     */
    void printRegistrationSummary();
}
-e \n\n===== File: ./src/main/java/sml/helperfiles/DefaultInstructionRegistrationLogger.java =====\n
package sml.helperfiles;

import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Default implementation of the {@link InstructionRegistrationLogger} for tracking
 * instruction class registration processes in the Simple Machine Language (SML) system.
 * <p>
 * This component provides a comprehensive logging mechanism for tracking
 * instruction class registration attempts, successes, and failures during
 * dynamic class discovery and registration.
 * </p>
 *
 * <h2>Key Features</h2>
 * <ul>
 *     <li>Tracks successful instruction registrations</li>
 *     <li>Captures details of failed registration attempts</li>
 *     <li>Generates a detailed registration summary</li>
 *     <li>Supports both console and logging framework output</li>
 * </ul>
 *
 * <p>
 * The logger maintains two internal lists:
 * <ol>
 *     <li>A list of successfully registered instructions</li>
 *     <li>A list of failed registration attempts</li>
 * </ol>
 * </p>
 *
 * <p>
 * Registration information can be printed to the console using
 * {@link #printRegistrationSummary()} method, which provides a
 * comprehensive overview of the registration process.
 * </p>
 *
 * @author Ricki Angel
 * @version 1.0
 * @see InstructionRegistrationLogger
 * @since 1.0
 */
@Component
public class DefaultInstructionRegistrationLogger implements InstructionRegistrationLogger {
    /**
     * List to track successfully registered instruction classes.
     * Each entry includes the instruction name and its opcode.
     */
    private static final List<String> SUCCESSFULLY_REGISTERED = new ArrayList<>();

    /**
     * List to track failed instruction registration attempts.
     * Each entry includes the instruction name and reason for failure.
     */
    private static final List<String> FAILED_REGISTRATION = new ArrayList<>();

    /**
     * System logger for recording registration events and errors.
     */
    private static final Logger LOGGER = Logger.getLogger(DefaultInstructionRegistrationLogger.class.getName());

    /**
     * Logs an attempt to register an instruction class.
     * <p>
     * Currently, this method is a no-op (commented out logging),
     * but can be extended to provide more detailed registration tracking.
     * </p>
     *
     * @param clazz The instruction class being registered
     */
    @Override
    public void logRegistrationAttempt(Class<?> clazz) {
//        LOGGER.log(Level.INFO, "Attempting to register class: " + clazz.getSimpleName());
    }

    /**
     * Tracks a successful instruction registration.
     * <p>
     * Adds the instruction name and its opcode to the list of successfully
     * registered instructions.
     * </p>
     *
     * @param instructionName Name of the successfully registered instruction
     * @param opcode          Opcode associated with the instruction
     */
    @Override
    public void trackSuccessfulRegistration(String instructionName, String opcode) {
        SUCCESSFULLY_REGISTERED.add(instructionName + " (opcode: " + opcode + ")");
//        LOGGER.log(Level.FINEST, "Successfully registered instruction: " + instructionName + " for opcode: " + opcode);
    }

    /**
     * Tracks a failed instruction registration attempt.
     * <p>
     * Logs the failure reason and adds the instruction to the failed
     * registration list. Outputs an error message to the console and
     * logs a warning through the logging framework.
     * </p>
     *
     * @param instructionName Name of the instruction that failed to register
     * @param reason          Explanation for the registration failure
     */
    @Override
    public void trackFailedRegistration(String instructionName, String reason) {
        FAILED_REGISTRATION.add(instructionName + " - " + reason);

        System.err.println("Instruction class not in /instructions folder: " + instructionName);

        LOGGER.log(Level.WARNING, "Failed to register instruction: " + instructionName + " - " + reason);
    }

    /**
     * Prints a comprehensive summary of the instruction registration process.
     * <p>
     * Outputs to the console:
     * <ul>
     *     <li>Details of successfully registered instructions</li>
     *     <li>List of failed registration attempts (if any)</li>
     *     <li>Total count of successful and failed registrations</li>
     * </ul>
     * </p>
     */
    @Override
    public void printRegistrationSummary() {
        System.out.println("\n=== Instruction Registration Summary ===");

        for (int i = 0; i < SUCCESSFULLY_REGISTERED.size(); i++) {
            System.out.println("   Attempting: " + SUCCESSFULLY_REGISTERED.get(i).split(" \\(")[0]);
            System.out.println("   Registered: " + SUCCESSFULLY_REGISTERED.get(i) + "\n");
        }

        if (!FAILED_REGISTRATION.isEmpty()) {
            System.out.println("\nFailed Registration Attempts:");
            FAILED_REGISTRATION.forEach(instruction -> System.out.println("   " + instruction));
        }

        System.out.println("\nTotal Registered: " + SUCCESSFULLY_REGISTERED.size());
        System.out.println("Total Failed: " + FAILED_REGISTRATION.size());
        System.out.println("=======================================\n");
    }
}
-e \n\n===== File: ./src/main/java/sml/helperfiles/package-info.java =====\n
/**
 * Provides utility components and interfaces for supporting the SML system.
 * <p>
 * This package contains helper classes that provide cross-cutting functionality:
 * <ul>
 *   <li>{@link sml.helperfiles.InstructionRegistrationLogger} - Interface for logging instruction registration</li>
 *   <li>{@link sml.helperfiles.DefaultInstructionRegistrationLogger} - Default implementation that tracks 
 *       successful and failed instruction registrations</li>
 * </ul>
 * </p>
 * <p>
 * These helper components provide detailed monitoring and debugging capabilities 
 * for the instruction discovery and registration process. The logger tracks:
 * <ul>
 *   <li>Successful instruction registrations with opcode mappings</li>
 *   <li>Failed registration attempts with detailed error reasons</li>
 *   <li>Summary statistics for registration processes</li>
 * </ul>
 * </p>
 * <p>
 * The components are designed for integration with Spring's dependency injection
 * system and provide both console output and logging framework integration.
 * </p>
 *
 * @author Ricki Angel
 * @see sml.discovery.InstructionDiscoveryStrategy
 * @see sml.InstructionRegistrationManager
 *  
 */
package sml.helperfiles;
-e \n\n===== File: ./src/main/java/sml/VariableNotFoundException.java =====\n
package sml;


/**
 * Exception thrown when a variable is not found.
 *
 * <p>This exception is typically used in situations where a variable is accessed or referenced,
 * but it is not found in the context where it is expected.</p>
 */
public class VariableNotFoundException extends RuntimeException {
    /**
     * Constructs a new {@code VariableNotFoundException} with a message indicating the variable
     * that was not found.
     *
     * @param var the identifier of the variable that was not found
     */
    public VariableNotFoundException(Variable.Identifier var) {
        super("Variable " + var + " not found");
    }
}
-e \n\n===== File: ./src/main/java/sml/Translator.java =====\n
package sml;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import sml.instructions.Instruction;
import sml.services.FileService;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Handles the orchestration of reading the file, managing state transitions, and adding methods to the program.
 * <p>
 * Responsible for reading SML code from source files, parsing language constructs, and converting the program into
 * executable {@link Method} objects with their associated {@link Instruction} objects and arguments. The parser
 * supports method definitions with parameters, labeled instructions for control flow, and various instruction types.
 * This modular design separates parsing from execution concerns, facilitating extensibility with new instruction types.
 *
 * @author Ricki Angel
 */
@Component
public final class Translator {
    private final FileService fileService;
    private String line = "";

    /**
     * Constructs a Translator with the given FileService.
     * <p>
     * This constructor injects the FileService dependency for file operations.
     * </p>
     *
     * @param fileService the FileService instance
     */
    @Autowired
    public Translator(FileService fileService) {
        this.fileService = fileService;
    }

    /**
     * This constructor is provided for situations where automatic DI is not used.
     * <p>
     * Provides a No-arguments constructor for backward compatibility with manual Dependency Injection (DI).
     * </p>
     */
    public Translator() {
        this.fileService = null;
    }

    // Holds the current method's name, its instructions, and its arguments while parsing:
    private static class State {
        final Method.Identifier methodName;
        final List<Instruction> instructions;
        final List<Variable.Identifier> arguments;

        /**
         * Constructor for creating a new parsing state with a method identifier.
         *
         * @param methodName the method identifier
         */
        State(Method.Identifier methodName) {
            this.methodName = methodName;
            instructions = new ArrayList<>();
            arguments = new ArrayList<>();
        }

        /**
         * Creates a Method object from the current state.
         * <p>
         * This method returns a Method with its name, arguments, and instructions.
         * </p>
         *
         * @return a newly created Method object
         */
        Method createMethod() {
            return new Method(methodName, arguments, instructions);
        }

        /**
         * Adds an argument to the method's argument list.
         *
         * @param name the argument's name
         */
        void addArgument(String name) {
            Variable.Identifier id = new Variable.Identifier(name);
            arguments.add(id);
        }
    }

    private static final String ITEM_SEPARATOR = ",";
    private static final String METHOD_LABEL = "@";

    /**
     * Reads and translates a .sml file into a collection of Method objects.
     * <p>
     * This method reads the SML program from the specified file, processes the lines, and creates a collection of
     * Method objects. Each Method consists of instructions and arguments parsed from the SML code.
     * </p>
     *
     * @param fileName the name of the file to read
     * @return a collection of Method objects
     * @throws IOException if an error occurs while reading the file
     */
    public Collection<Method> readAndTranslate(String fileName) throws IOException {
        Collection<Method> methods = new ArrayList<>();

        // Use fileService or fall back to direct file access
        try (Scanner sc = fileService != null
                ? fileService.createFileScanner(fileName)
                : new Scanner(new File(fileName), StandardCharsets.UTF_8)) {

            State state = null;
            while (sc.hasNextLine()) {
                line = sc.nextLine();
                String labelString = getLabel();

                if (labelString != null && labelString.startsWith(METHOD_LABEL)) {
                    if (state != null) methods.add(state.createMethod());

                    state = new State(new Method.Identifier(labelString));
                    processMethodArguments(state);
                } else {
                    Label label = labelString != null ? new Label(labelString) : null;
                    Instruction instruction = getInstruction(label);

                    if (instruction != null) {
                        if (state != null)
                            state.instructions.add(instruction);
                        else
                            throw new IllegalArgumentException("Instruction cannot appear outside methods " + labelString + " " + instruction);
                    }
                }
            }
            if (state != null) methods.add(state.createMethod());
        }
        return methods;
    }

    /**
     * Processes the arguments of a method from the current line and adds them to the state.
     *
     * @param state the state representing the current method being parsed
     */
    private void processMethodArguments(State state) {
        for (String s = scan(); !s.isEmpty(); s = scan()) {
            String variable = s.endsWith(ITEM_SEPARATOR)
                    ? s.substring(0, s.length() - 1).trim()
                    : s;

            state.addArgument(variable);

            if (!s.endsWith(ITEM_SEPARATOR)) break;
        }
    }

    /**
     * Gets an Instruction based on the current label in the SML code.
     *
     * @param label the label associated with the instruction
     * @return the corresponding Instruction object or null if not found
     */
    private Instruction getInstruction(Label label) {
        String opcode = scan();
        if (opcode.isEmpty()) return null;

        try {
            String className = getInstructionClassName(opcode);
            Class<?> instructionClass = Class.forName(className);
            return createInstructionInstance(instructionClass, label);
        } catch (ClassNotFoundException e) {
            System.err.println("Instruction class not found for opcode: " + opcode);
            return null;
        } catch (ReflectiveOperationException e) {
            System.err.println("Error creating instruction for opcode: " + opcode);
            return null;
        }
    }

    private String getInstructionClassName(String opcode) {
        String normalizedOpcode = normaliseOpcode(opcode);
        return "sml.instructions." + normalizedOpcode + "Instruction";
    }

    /**
     * Normalises the opcode by capitalising and removing underscores.
     *
     * @param opcode the opcode to normalise
     * @return the normalized opcode
     */
    private String normaliseOpcode(String opcode) {
        if (!opcode.contains("_")) {
            return capitalise(opcode);
        }
        return Arrays.stream(opcode.split("_"))
                .map(this::capitalise)
                .collect(Collectors.joining());
    }

    private String capitalise(String str) {
        return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();
    }

    /**
     * Creates an Instruction instance based on the instruction class and label.
     *
     * <p>Instantiates a new instruction by finding an appropriate constructor 
     * and creating an instance with the given label and additional arguments.</p>
     *
     * @param instructionClass the class representing the instruction to be created
     * @param label the label associated with the instruction (can be null)
     * @return a new Instruction object
     * @throws ClassNotFoundException if the instruction class cannot be found
     * @throws ReflectiveOperationException if there are issues creating the instruction instance
     */
    private Instruction createInstructionInstance(Class<?> instructionClass, Label label) throws ClassNotFoundException, ReflectiveOperationException {
        var constructor = findLabelConstructor(instructionClass);
        Object[] args = buildConstructorArgs(constructor, label);
        return (Instruction) constructor.newInstance(args);
    }

    /**
     * Finds the constructor of the instruction class that takes a Label as the first argument.
     *
     * @param instructionClass the instruction class
     * @return the found constructor
     */
    private Constructor<?> findLabelConstructor(Class<?> instructionClass) {
        return Arrays.stream(instructionClass.getDeclaredConstructors())
                .filter(c -> c.getParameterTypes().length > 0 && c.getParameterTypes()[0] == Label.class)
                .findFirst()
                .orElseThrow(() -> new IllegalArgumentException("No valid constructor found"));
    }

    private Object[] buildConstructorArgs(Constructor<?> constructor, Label label) {
        var paramTypes = constructor.getParameterTypes();
        Object[] args = new Object[paramTypes.length];
        args[0] = label;

        for (int i = 1; i < paramTypes.length; i++) {
            String arg = scan();
            args[i] = convertArgument(arg, paramTypes[i]);
        }

        return args;
    }

    private Object convertArgument(String arg, Class<?> paramType) {
        return switch (paramType.getName()) {
            case "sml.Label" -> new Label(arg);
            case "sml.Variable$Identifier" -> new Variable.Identifier(arg);
            case "sml.Method$Identifier" -> new Method.Identifier(arg);
            case "int" -> Integer.parseInt(arg);
            default -> throw new IllegalArgumentException(
                    "Unsupported parameter type: " + paramType.getName());
        };
    }

    /**
     * Extracts and removes a leading label from the line, if present.
     *
     * @return label string without trailing colon, or null if absent
     */
    private String getLabel() {
        String word = scan();
        if (word.endsWith(":")) return word.substring(0, word.length() - 1);

        line = word + " " + line;
        return null;
    }

    /**
     * Returns the first word of line and removes it from line.
     * If there is no word, return "".
     *
     * @return the next word from the current line
     */
    public String scan() {
        line = line.trim();

        if (line.isEmpty()) {
            return "";
        }

        int whiteSpacePosition = 0;
        while (whiteSpacePosition < line.length()) {
            if (Character.isWhitespace(line.charAt(whiteSpacePosition))) break;
            whiteSpacePosition++;
        }

        String word = line.substring(0, whiteSpacePosition);
        line = line.substring(Math.min(whiteSpacePosition, line.length()));
        return word;
    }
}
-e \n\n===== File: ./src/main/java/sml/registry/InstructionRegistry.java =====\n
package sml.registry;

import sml.Label;
import sml.instructions.Instruction;

import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Registry of available SML instruction classes.
 * <p>
 * Maintains a mapping of opcodes to their corresponding instruction classes
 * and provides methods for instruction instantiation.
 * </p>
 *
 * @author Ricki Angel
 */
public class InstructionRegistry {
    private static final Logger LOGGER = Logger.getLogger(InstructionRegistry.class.getName());
    private final Map<String, Class<? extends Instruction>> instructionMap = new HashMap<>();

    /**
     * Registers an instruction class with its corresponding opcode.
     *
     * @param opcode The opcode to register
     * @param instructionClass The instruction class to register
     */
    public void register(String opcode, Class<? extends Instruction> instructionClass) {
        instructionMap.put(opcode, instructionClass);
    }

    /**
     * Checks if an opcode is already registered.
     *
     * @param opcode The opcode to check
     * @return true if the opcode is registered, false otherwise
     */
    public boolean isRegistered(String opcode) {
        return instructionMap.containsKey(opcode);
    }

    /**
     * Returns the number of registered instructions.
     *
     * @return The count of registered instructions
     */
    public int size() {
        return instructionMap.size();
    }

    /**
     * Creates an instruction instance for the given opcode.
     *
     * @param opcode The opcode of the instruction to create
     * @param label The label for the instruction (can be null)
     * @return The created instruction, or null if creation fails
     */
    public Instruction createInstruction(String opcode, Label label) {
        Class<? extends Instruction> instructionClass = instructionMap.get(opcode);
        if (instructionClass == null) {
            LOGGER.log(Level.WARNING, "No instruction class found for opcode: " + opcode);
            return null;
        }

        try {
            Constructor<? extends Instruction> constructor = instructionClass.getConstructor(Label.class);
            return constructor.newInstance(label);
        } catch (NoSuchMethodException e) {
            LOGGER.log(Level.SEVERE, "No constructor with Label parameter found for opcode: " + opcode, e);
        } catch (ReflectiveOperationException e) {
            LOGGER.log(Level.WARNING, "Error creating instruction for opcode: " + opcode, e);
        }
        return null;
    }
}
-e \n\n===== File: ./src/main/java/sml/registry/package-info.java =====\n
/**
 * Provides registry mechanisms for managing instruction creation and lookup.
 * <p>
 * This package contains the registry system that maintains opcode-to-instruction mappings:
 * <ul>
 *   <li>{@link sml.registry.InstructionRegistry} - Maintains a mapping of opcodes to instruction classes
 *       and provides methods for instruction instantiation</li>
 * </ul>
 * </p>
 * <p>
 * The registry system serves as a centralised repository for instruction class information,
 * enabling:
 * <ul>
 *   <li>Dynamic registration of instructions at runtime</li>
 *   <li>Opcode-based instruction instantiation</li>
 *   <li>Verification of instruction availability</li>
 *   <li>Managing instruction creation with appropriate parameters</li>
 * </ul>
 * </p>
 * <p>
 * The registry works in conjunction with the discovery system to provide a complete
 * solution for instruction lifecycle management in the SML virtual machine.
 * </p>
 *
 * @author Ricki Angel
 * @see sml.discovery.InstructionDiscoveryStrategy
 * @see sml.InstructionRegistrationManager
 */
package sml.registry;
-e \n\n===== File: ./src/main/java/sml/LabelNotFoundException.java =====\n
package sml;

/**
 * An exception raised when a label cannot be located within a method.
 *
 * <p>Manages the handling of label lookup failures during Simple Machine Language (SML) program execution.</p>
 *
 * <p>Key features:</p>
 * <ul>
 *   <li>Provides detailed context about the missing label</li>
 *   <li>Stores the problematic label and method for further investigation</li>
 *   <li>Generates informative error messages</li>
 *   <li>Supports debugging of label resolution issues</li>
 * </ul>
 *
 * <p>Enhances error reporting by capturing specific details of label lookup failures.</p>
 *
 * @author Ricki Angel
 */
public class LabelNotFoundException extends RuntimeException {
    /**
     * The label that could not be found within the method.
     * Stored to provide context about the specific label causing the exception.
     */
    private final Label label;

    /**
     * The method in which the label lookup failed.
     * Provides crucial context for understanding the source of the label resolution error.
     */
    private final Method method;

    /**
     * Constructs a new LabelNotFoundException with the specified label and method.
     *
     * @param label  The label that was not found
     * @param method The method in which the label lookup failed
     */
    public LabelNotFoundException(Label label, Method method) {
        super("Label " + label + " not found in " + method.name());
        this.label = label;
        this.method = method;
    }

    /**
     * Retrieves the label that was not found.
     *
     * @return The label associated with this exception
     */
    public Label getLabel() {
        return label;
    }

    /**
     * Retrieves the method in which the label was not found.
     *
     * @return The method associated with this exception
     */
    public Method getMethod() {
        return method;
    }
}
-e \n\n===== File: ./src/main/java/sml/services/FileService.java =====\n
package sml.services;

import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;

/**
 * Service class providing file reading utilities for the Simple Machine Language program.
 * This service offers methods for creating file scanners with UTF-8 encoding.
 * <p>
 * The class is annotated with Spring's {@code @Service} stereotype, indicating it is a
 * Spring-managed service component that can be automatically discovered and injected.
 * </p>
 *
 * @author Ricki Angel
 */
@Service
public class FileService {

    /**
     * Creates a {@code Scanner} for reading the contents of a file with UTF-8 encoding.
     * <p>
     * This method opens a file at the specified path and returns a {@code Scanner}
     * that can be used to read the file's contents. The scanner uses UTF-8 character encoding
     * to ensure proper handling of international characters.
     * </p>
     *
     * @param path The file path from which to create the scanner. Must be a valid,
     *             accessible file path on the local filesystem.
     * @return A {@code Scanner} configured to read the specified file with UTF-8 encoding.
     * @throws IOException If an I/O error occurs while attempting to open the file,
     *                     such as the file not existing, being inaccessible, or other
     *                     filesystem-related issues.
     * @see java.util.Scanner
     * @see java.nio.charset.StandardCharsets
     * @see java.io.File
     */
    public Scanner createFileScanner(String path) throws IOException {
        return new Scanner(new File(path), StandardCharsets.UTF_8);
    }
}
-e \n\n===== File: ./src/main/java/sml/services/package-info.java =====\n
/**
 * Provides service components for file processing and resource management.
 * <p>
 * This package contains service classes that handle file operations for the SML system:
 * <ul>
 *   <li>{@link sml.services.FileService} - Manages file access with UTF-8 encoding support</li>
 * </ul>
 * </p>
 * <p>
 * The services in this package follow the Spring Framework's service pattern,
 * enabling dependency injection and separation of concerns. The file service
 * abstracts file system interactions, providing a clean interface for reading
 * program source files with consistent character encoding handling.
 * </p>
 * <p>
 * These services can be extended to support additional resource operations
 * like network access, database connections, or other external system integrations.
 * </p>
 *
 * @author Ricki Angel
 * @see sml.Translator
 */
package sml.services;
-e \n\n===== File: ./src/main/java/sml/package-info.java =====\n
/**
 * <h1>Simple Machine Language (SML) Interpreter</h1>
 *
 * <p>
 * This project implements an interpreter for the Simple Machine Language (SML),
 * a stack-based language designed for educational purposes. The interpreter provides
 * a virtual machine environment supporting arithmetic operations, control flow,
 * method invocation, and variable manipulation.
 * </p>
 *
 * <p>
 * Developed as a coursework assignment for the Software Design and Programming module,
 * part of the MSc Computer Science course at Birkbeck, University of London.
 * </p>
 *
 * <h2>Architecture Overview</h2>
 *
 * <ul>
 *   <li><strong>Machine:</strong> Manages program execution, frames, and instruction handling.</li>
 *   <li><strong>Instruction Set:</strong> Implements operations like arithmetic, control flow, and variable access.</li>
 *   <li><strong>Dynamic Discovery:</strong> Registers new instructions via configuration files or package scanning.</li>
 *   <li><strong>Translator:</strong> Converts SML source code into executable structures.</li>
 *   <li><strong>Frame System:</strong> Maintains operand stacks and variable storage for method execution.</li>
 * </ul>
 *
 * <h2>Key Design Features</h2>
 *
 * <ul>
 *   <li><strong>Extensibility:</strong> New instructions can be added dynamically.</li>
 *   <li><strong>Design Patterns:</strong> Utilizes Factory, Strategy, and Template Method patterns.</li>
 *   <li><strong>Spring Integration:</strong> Supports dependency injection but functions independently if needed.</li>
 *   <li><strong>Strong Typing:</strong> Uses record classes and wrapper types for safety.</li>
 *   <li><strong>Comprehensive Testing:</strong> Includes extensive unit and integration tests.</li>
 * </ul>
 *
 * <h2>Language Features</h2>
 *
 * <ul>
 *   <li><strong>Arithmetic:</strong> Operations like add, sub, mul, div, mod, sqrt.</li>
 *   <li><strong>Control Flow:</strong> Conditional/unconditional jumps, comparisons.</li>
 *   <li><strong>Methods:</strong> Parameterized calls, return values, nested execution.</li>
 *   <li><strong>Variables:</strong> Named storage, load/store operations.</li>
 *   <li><strong>Stack Manipulation:</strong> Push/pop operations for constants.</li>
 *   <li><strong>I/O:</strong> Basic print statements.</li>
 * </ul>
 *
 * <h2>Extending the Interpreter</h2>
 *
 * <ol>
 *   <li><strong>Adding Instructions:</strong> Extend {@link sml.instructions.Instruction} and define an OP_CODE.</li>
 *   <li><strong>Custom Discovery:</strong> Implement {@link sml.discovery.InstructionDiscoveryStrategy}.</li>
 *   <li><strong>Feature Extensions:</strong> Introduce new data types, control structures, or I/O features.</li>
 * </ol>
 *
 * <h2>Usage Examples</h2>
 * 
 * <h4>Using Command Line Interface:</h4>
  * <table>
 *   <tr>
 *     <th align="center">Linux / Mac OS CLI</th>
 *     <th align="center">Windows / PowerShell CLI</th>
 *   </tr>
 *   <tr>
 *     <td align="center">
 *       <a href="https://youtu.be/5946Zzi-ORM" target="_blank">
 *         <img src="doc-files/MacSMLsetup.jpg" alt="Linux / Mac OS setup" width="380">
 *       </a>
 *       <br>
 *       <em>Click to watch Linux / Mac OS CLI setup</em>
 *     </td>
 *     <td align="center">
 *       <a href="https://youtu.be/7FYMgWmGP08" target="_blank">
 *         <img src="doc-files/WinSMLsetup.jpg" alt="Windows (PowerShell) CLI setup" width="380">
 *       </a>
 *       <br>
 *       <em>Click to watch Windows (PowerShell) CLI setup</em>
 *     </td>
 *   </tr>
 * </table>
  * <h4>Using Spring Framework:</h4>
 * <pre>
 * ApplicationContext context = new AnnotationConfigApplicationContext(SmlConfig.class);
 * RunSml runner = context.getBean(RunSml.class);
 * runner.run("src/resources/your{program.sml");
 * </pre> 
 * <h4>Without Spring Framework:</h4>
 * <pre>
 * RunSml.create().run("src/resources/yourProgram.sml");
 * </pre>
 *
 * <h2>Example Programs</h2>
 *
 * <table border="1" cellspacing="0" cellpadding="5" style="border-collapse: collapse; border: 1px solid black;">
 *   <tr>
 *     <th>Filename</th>
 *     <th>Description</th>
 *   </tr>
 *   <tr>
 *     <td>test1.sml</td>
 *     <td>Recursive Fibonacci calculation.</td>
 *   </tr>
 *   <tr>
 *     <td>test2.sml</td>
 *     <td>Iterative Fibonacci calculation.</td>
 *   </tr>
 *   <tr>
 *     <td>sqrtest.sml</td>
 *     <td>Tests square root calculations.</td>
 *   </tr>
 *   <tr>
 *     <td>numchar.sml</td>
 *     <td>Converts numbers to letters and prints ASCII values.</td>
 *   </tr>
 *   <tr>
 *     <td>simplecalc.sml</td>
 *     <td>Performs multiplication, stores result, and uses conditional jumps.</td>
 *   </tr>
 *   <tr>
 *     <td>simple.sml</td>
 *     <td>Tests an undefined `int_to_str` instruction.</td>
 *   </tr>
 * </table>
 *
 * <h2>Project Structure</h2>
 *
 * <ul>
 *   <li>{@link sml.instructions} - Instruction implementations.</li>
 *   <li>{@link sml.discovery} - Instruction discovery mechanisms.</li>
 *   <li>{@link sml.registry} - Manages instruction registration.</li>
 *   <li>{@link sml.services} - Service components (e.g., file handling).</li>
 *   <li>{@link sml.config} - Spring configuration and properties.</li>
 *   <li>{@link sml.helperfiles} - Utility functions and logging.</li>
 * </ul>
 *
 * <h2>System Requirements</h2>
 *
 * <ul>
 *   <li>Java 23 or higher.</li>
 *   <li>Maven 3.8.0+ for building.</li>
 *   li>JUnit 5.11.4 for unit testing..</li>
 *   <li>Spring Framework 6.2.2 (optional).</li>
 * </ul>
 *
 * @author Ricki Angel
 * @version 1.0
 * @see sml.Machine
 * @see sml.instructions.Instruction
 * @see sml.discovery.InstructionDiscoveryStrategy
 * @see sml.RunSml
 */
package sml;
-e \n\n===== File: ./src/main/java/sml/InstructionRegistrationManager.java =====\n
package sml;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.beans.factory.annotation.Qualifier;

import sml.discovery.ConfigDiscovery;
import sml.discovery.InstructionDiscoveryStrategy;
import sml.discovery.PackageScanDiscovery;
import sml.helperfiles.InstructionRegistrationLogger;
import sml.instructions.Instruction;
import sml.registry.InstructionRegistry;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.logging.*;

/**
 * A dynamic Factory for creating SML instructions.
 *
 * <h2>Discovery Strategies</h2>
 * <p>The InstructionRegistrationManager supports two primary strategies for discovering instructions:</p>
 * <ol>
 *   <li><strong>Configuration File Discovery</strong>: 
 *       Reads instruction mappings from a properties file, allowing dynamic registration 
 *       without modifying code.</li>
 *   <li><strong>Package Scanning</strong>: 
 *       Automatically detects instruction classes within a specified package, 
 *       using reflection to identify and register available instructions.</li>
 * </ol>
 *
 * <h2>Key Features</h2>
 * <ul>
 *   <li>Dynamic instruction registration without code modifications</li>
 *   <li>Extensible discovery mechanisms</li>
 *   <li>Centralised instruction management</li>
 *   <li>Logging and tracking of instruction registration processes</li>
 *   <li>Fail-fast mechanism for instruction discovery</li>
 * </ul>
 *
 * <h2>Delegation Model</h2>
 * <p>This factory delegates core functionality to specialised components:</p>
 * <ul>
 *   <li>Storage and creation of instructions is handled by {@link InstructionRegistry}</li>
 *   <li>Discovery of instructions is performed by {@link InstructionDiscoveryStrategy} implementations</li>
 * </ul>
 *
 * @author Ricki Angel
 */
@Component("InstructionFactory")
@Qualifier
public class InstructionRegistrationManager {
    private static final Logger LOGGER = Logger.getLogger(InstructionRegistrationManager.class.getName());
    private static final InstructionRegistry REGISTRY = new InstructionRegistry();

    private final InstructionRegistrationLogger logger;
    private final List<InstructionDiscoveryStrategy> discoveryMethods = new ArrayList<>();

    static {
        configureLoggerFormat();
        initialiseFactory();
    }

    /**
     * Configures console log handlers to provide cleaner, simplified output.
     *
     * <p>Replaces default log formatting with a streamlined message-only display.</p>
     */
    private static void configureLoggerFormat() {
        Logger rootLogger = Logger.getLogger("");
        for (Handler handler : rootLogger.getHandlers()) {
            if (handler instanceof ConsoleHandler) {
                handler.setFormatter(new SimpleFormatter() {
                    @Override
                    public synchronized String format(LogRecord record) {
                        return record.getMessage() + System.lineSeparator();
                    }
                });
            }
        }
    }

    /**
     * Initialises the static factory with discovery methods.
     *
     * <p>Discovers and registers available instructions, then prints a registration summary.</p>
     */
    private static void initialiseFactory() {
        InstructionRegistrationLogger staticLogger =
                new sml.helperfiles.DefaultInstructionRegistrationLogger();
        InstructionRegistrationManager factory = new InstructionRegistrationManager(staticLogger);
        factory.discoverInstructions();
        staticLogger.printRegistrationSummary();
    }

    /**
     * Constructs a new InstructionRegistrationManager.
     *
     * @param logger The logger for tracking instruction registration
     */
    @Autowired
    public InstructionRegistrationManager(InstructionRegistrationLogger logger) {
        this.logger = Objects.requireNonNull(logger, "Logger cannot be null");

        discoveryMethods.add(new ConfigDiscovery(logger));
        discoveryMethods.add(new PackageScanDiscovery(logger));
    }

    /**
     * Discovers instructions using the configured discovery methods.
     * <p>
     * Attempts each method in sequence until successful.
     * </p>
     */
    public void discoverInstructions() {
        LOGGER.log(Level.INFO, "Starting instruction discovery process");

        boolean success = false;
        for (InstructionDiscoveryStrategy method : discoveryMethods) {
            int discovered = method.discoverInstructions(REGISTRY);
            if (discovered > 0) {
                LOGGER.log(Level.INFO, "Successfully discovered " + discovered +
                        " instructions using " + method.getName() + " method");
                success = true;
                break;
            }
        }

        if (!success) {
            LOGGER.log(Level.SEVERE, "Failed to discover any instructions using all methods");
            throw new RuntimeException("No instructions could be discovered");
        }
    }

    /**
     * Creates an instruction based on the given opcode and label.
     * <p>
     * This is the primary method for instantiating instructions.
     * </p>
     *
     * @param opcode The operation code identifying the instruction type
     * @param label  The label associated with the instruction
     * @return A new Instruction instance, or null if creation fails
     */
    public static Instruction createInstruction(String opcode, Label label) {
        return REGISTRY.createInstruction(opcode, label);
    }
}
